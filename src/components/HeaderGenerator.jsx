import React, { useState } from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { a11yDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import { generateStringLiteral, generateByteArrayLiteral, toIdentifier } from './CGen';
import './HeaderGenerator.css';

const isText = (type) => {
    return (type.endsWith("/json") || type.endsWith("/xml") || type.endsWith("+xml") || type.startsWith("text/"));
}
const isSupportedImage = (fileInfo) => {
    const fileName = fileInfo.file.name.toLowerCase();
    const fileType = fileInfo.file.type;
    if(fileType=="image/jpg" || fileType=="image/png" || fileType=="image/svg+xml") {
        return true;
    }
    if(fileName.endsWith(".jpg") || fileName.endsWith(".png") || fileName.endsWith(".svg") || fileName.endsWith(".tvg")) {
         return true;
    }
}
const tvgAdvCoord = (range) => {   
    switch(range) {
        case 0://"default"
            return 2;        
        case 1://"reduced":
            return 1;
        case 2://"extended"
            return 4;
    }
}
const tvgMapZeroToMax = (range,value) => {
    if(0==value) {
        switch(range) {
            case 0: //"default"
                return 0xFFFF;
            case 1: //"reduced"
                return 0xFF;
            case 2: //"extended"
                return 0xFFFFFFFF;
        }
        return undefined;
    }
    return value;
}
const tvgReadCoord = (range,startIndex,data) => {   
    const view = new DataView(data);
    switch(range) {
        case 0: //"default"
            return view.getUint16(startIndex,true);
        
        case 1: //"reduced"
            return view.getUint8(startIndex);
        
        case 2: //"extended"
            return view.getUint32(startIndex,true);    
    }
    return undefined;
}
const tvgReadDimensions = (data) => {
    const view = new DataView(data);
    if(view.byteLength>5) {
        // check for TVG v 1.0 header
        if(view.getUint8(0)==0x72 && view.getUint8(1)==0x56 && view.getUint8(2)==1) {
            const flags = view.getUint8(3);
            const range = (flags>>>6)&0x03;
            const w = tvgReadCoord(range,4,data);
            const h = tvgReadCoord(range,4+tvgAdvCoord(range),data);
            const dim = {
                width: tvgMapZeroToMax(range,w),
                height:tvgMapZeroToMax(range,h)
            };
            return dim;
        }
    }
    return undefined;
}
const isTrueType = (name) => {
    const n = name.toLowerCase();
    return n.endsWith(".ttf") || n.endsWith(".otf");
}

const generateHeader = (identifier, fileInfo, imageDim, imageScale, fontSetIndex, size, units, outputType, data) => {
    let result = "";
    if (imageScale === undefined || imageScale === "") {
        imageScale = "scale_1_1";
    }
    const fileName = fileInfo.file.name;
    const fileType = fileInfo.file.type;
    const isGfx = (outputType != undefined && outputType.length > 0 && outputType != "C");
    const guard = identifier.toUpperCase() + ((isGfx) ? "_HPP" : "_H");
    const impl = identifier.toUpperCase() + "_IMPLEMENTATION";
    result += "// Automatically generated by https://honeythecodewitch.com/gfx/header\r\n";
    result += `// #define ${impl} in exactly one\r\n`;
    result += "// translation unit (.c/.cpp file) before including this header\r\n";
    result += `#ifndef ${guard}\r\n`;
    result += `#define ${guard}\r\n`;
    const istext = isText(fileType);
    if (!istext) {
        result += "#include <stdint.h>\r\n";
    }
    var imgSize;
    if(imageDim && imageDim.width && imageDim.height && imageDim.width>0 && imageDim.height>0) {
        imgSize = imageDim;
    }
    let isSpecialized = false;
    let isFon = false;
    let isTtf = false;
    let isVlw = false;
    let isJpg = false;
    let isPng = false;
    let isSvg = false;
    let isTvg = false;
        if (fileType === undefined || fileType === "" && fileName.toLowerCase().endsWith(".fon")) {
            isFon = true;
            isSpecialized = isFon;
        } else if (fileType === "image/jpeg") {
            isJpg = true;
            isSpecialized = true;
        } else if (fileType === "image/svg+xml") {
            isSvg = true;
        } else if(fileName.toLowerCase().endsWith(".tvg")) {
            isTvg = true;
        } else if (fileType === "image/png") {
            isPng = true;
            isSpecialized = true;
        } else if (fileName.toLowerCase().endsWith(".vlw")) {
            isVlw = true;
            isSpecialized = true;
        } else if (isTrueType(fileName) && size && !isNaN(size) && size != 0 && units) {
            isTtf = true;
            isSpecialized = true;
        }
    if (isGfx) {
        if (isFon) {
            result += "#include \"gfx_win_font.hpp\"\r\n\r\n";
            result += `extern gfx::win_font ${identifier};\r\n`
        } else if (isVlw) {
            result += "#include \"gfx_vlw_font.hpp\"\r\n\r\n";
            result += `extern gfx::vlw_font ${identifier};\r\n`
        } else if (isJpg) {
            result += "#include \"gfx_jpg_image.hpp\"\r\n\r\n";
            if(imgSize) {
                result+=`#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += `extern gfx::jpg_image ${identifier};\r\n`
        } else if (isPng) {
            result += "#include \"gfx_png_image.hpp\"\r\n\r\n";
            if(imgSize) {
                result+=`#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += `extern gfx::png_image ${identifier};\r\n`
        } else if (isTtf) {
            result += "#include \"gfx_ttf_font.hpp\"\r\n\r\n";
            result += `extern gfx::ttf_font ${identifier};\r\n`
        } else {
            result += "#include \"gfx_core.hpp\"\r\n\r\n";
            if(isSvg || isTvg) {
                if(imgSize) {
                    result+=`#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                }
            }
            result += `extern gfx::const_buffer_stream ${identifier};\r\n`;
        }
    } else {
        if (istext) {
            if (data) {
                const view = new DataView(data);
                result += `#define ${identifier.toUpperCase()}_LENGTH (${view.byteLength})\r\n`;
            } else {
                result += `#define ${identifier.toUpperCase()}_LENGTH (${fileInfo.file.size})\r\n`;
            }
            if((isSvg || isTvg || isPng || isJpg) && imgSize) {
                result+=`#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
            result += `const char* ${identifier};\r\n`;
        } else {
            if((isSvg || isTvg || isPng || isJpg) && imgSize) {
                result+=`#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += `const uint8_t ${identifier}[];\r\n`;
        }
    }
    result += `#endif // ${guard}\r\n\r\n`;
    result += `#ifdef ${impl}\r\n`;
    if (isGfx) {
        if (istext) {
            result += generateStringLiteral(identifier + "_data", data, true) + "\r\n\r\n";
        } else {
            result += generateByteArrayLiteral(identifier + "_data", data, true) + "\r\n\r\n";
        }
        if (isSpecialized) {
            result += `static gfx::const_buffer_stream ${identifier}_stream(${identifier}_data, sizeof(${identifier}_data));\r\n`;
        }
        if (isFon) {
            if (fontSetIndex != 0) {
                result += `gfx::win_font ${identifier}(${identifier}_stream, ${fontSetIndex});\r\n`;
            } else {
                result += `gfx::win_font ${identifier}(${identifier}_stream);\r\n`;
            }
        } else if (isVlw) {
            result += `gfx::vlw_font ${identifier}(${identifier}_stream);\r\n`;
        } else if (isJpg) {
            if (imageScale != "scale_1_1") {
                result += `gfx::jpg_image ${identifier}(${identifier}_stream, jpg_scale::${imageScale});\r\n`;
            } else {
                result += `gfx::jpg_image ${identifier}(${identifier}_stream);\r\n`;
            }
        } else if (isPng) {
            result += `gfx::png_image ${identifier}(${identifier}_stream);\r\n`;
        } else if (isTtf) {
            result += `gfx::ttf_font ${identifier}(${identifier}_stream, ${size}, gfx::font_size_units::${units})\r\n`;
        } else {
            if (istext) {
                if (data) {
                    const view = new DataView(data);
                    result += `gfx::const_buffer_stream ${identifier}((const uint8_t*)${identifier}_data, ${view.byteLength});\r\n`;
                } else {
                    result += `gfx::const_buffer_stream ${identifier}((const uint8_t*)${identifier}_data, ${fileInfo.file.size});\r\n`;
                }
            } else {
                result += `gfx::const_buffer_stream ${identifier}(${identifier}_data, sizeof(${identifier}_data));\r\n`;
            }
        }
    } else {
        if (istext) {
            result += generateStringLiteral(identifier, data, false) + "\r\n";
        } else {
            result += generateByteArrayLiteral(identifier, data, false) + "\r\n";
        }
    }
    result += `#endif // ${impl}\r\n`;
    return result;
}
const getDownloadName = (ident, genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return `${ident}.h`;
    }
    return `${ident}.hpp`;
}
const getGeneratedLanguage = (genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return "c";
    }
    return "cpp";
}
const HeaderGenerator = () => {
    let downloadUrl = "";
    var gencache;
    var imageDimensions;
    const [fileInfo, setFileInfo] = useState("");
    const [ident, setIdent] = useState("");
    const [fontSet, setFontSet] = useState("");
    const [fontSize, setFontSize] = useState("");
    const [fontUnits, setFontUnits] = useState("");
    const [imageScale, setImageScale] = useState("");
    const [imageDim, setImageDim] = useState("");
    const [genType, setGenType] = useState("");
    const handleFileChange = (e) => {
        setFileInfo({ file: e.target.files[0], type: e.target.files[0].type });
        setIdent(toIdentifier(e.target.files[0].name));
        gencache = undefined;
    };
    const handleIdentChange = (e) => {
        if (ident != e.target.value) {
            setIdent(e.target.value);
            gencache = undefined;
        }
    }
    const handleFontSetValueChange = (e) => {
        let n = Number.parseInt(e.target.value);
        if (isNaN(n)) {
            n = 0;
        }
        setFontSet(n);
        gencache = undefined;
    }
    const handleImageScaleChange = (e) => {
        let s = e.target.value;
        if (s === undefined || s === "") {
            s = "scale_1_1";
        }
        setImageScale(s);
        gencache = undefined;
    }
    const handleFontSizeValueChange = (e) => {
        let n = Number.parseInt(e.target.value);
        if (isNaN(n)) {
            n = 0;
        }
        setFontSize(n);
        gencache = undefined;
    }
    const handleFontSizeUnitChange = (e) => {
        let u = e.target.value;
        if (u === "none" || u === undefined || u === "") {
            setFontSize(0);
            setFontUnits(u);
            return;
        }
        if (u != "em" && u != "px") {
            u = "em";
        }
        setFontUnits(u);
        setFontSize(fontSize); // force a refresh
        gencache = undefined;
    }
    const handleTypeChange = (e) => {
        if (genType != e.target.value) {
            setGenType(e.target.value);
            gencache = undefined;
        }
    }

    const readImageDimensions = async (data) => {
        return new Promise((resolve, reject) => {
            let dim = tvgReadDimensions(data);
            if(dim) {
                resolve(dim);        
            } 
            else {
                const imgsrc = URL.createObjectURL(new Blob([data]));
                const img = new Image();
                img.onload = () => {
                    dim = {
                        width: img.naturalWidth,
                        height: img.naturalHeight
                    };
                    resolve(dim);
                };

                img.onerror = () => {
                    // try SVG on fallback
                    var decoder = new TextDecoder('utf-8');
                    const svgstr = decoder.decode(data);
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgstr, 'image/svg+xml');
                    const svg = doc.documentElement;
                    
                    // Get bounding box of all content
                    document.body.appendChild(svg);
                    const bbox = svg.getBBox();
                    document.body.removeChild(svg);
                    dim = {
                        width: Math.ceil(bbox.width + bbox.x),
                        height: Math.ceil(bbox.height + bbox.y)
                    };
                    if(dim && dim.width>0) {
                        resolve(dim);
                    } else {
                        reject();
                    }
                }
                img.src = imgsrc;
            }
        });
    }
    const getCreatedTypeName = () => {
        if (fileInfo) {
            if (!genType || genType === "" || genType === "C") {
                if (isText(fileInfo.type)) {
                    return "const char*";
                } else {
                    return "const uint8_t[]";
                }
            }
            const fileType = fileInfo.type;
            const fileName = fileInfo.file.name;
            const size = fontSize;
            const units = fontUnits;
            if (fileType === undefined || fileType === "" && fileName.toLowerCase().endsWith(".fon")) {
                return "gfx::win_font";
            } else if (fileType === "image/jpeg") {
                return "gfx::jpg_image";
            } else if (fileType === "image/png") {
                return "gfx::png_image";
            } else if (fileName.toLowerCase().endsWith(".vlw")) {
                return "gfx::vlw_font";
            } else if (isTrueType(fileName) && size && !isNaN(size) && size != 0 && units) {
                return "gfx::ttf_font";
            }

            return "gfx::const_buffer_stream";

        }
        return undefined;
    }

    const generateContentClip = () => {
        if (!gencache && fileInfo.file) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(fileInfo.file);
            reader.onload = async function (evt) {
                console.log("generating content to clipboard");
                gencache = generateHeader(ident, fileInfo, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, evt.target.result);
                await navigator.clipboard.writeText(gencache);
            }
        } else if (gencache) {
            console.log("writing content to clipboard");
            navigator.clipboard.writeText(gencache);
        }
    }
    const setGeneratedFileUrl = () => {
        // this is a hack. alink must be created outside React's normal rendering sequence
        // due to the on the fly generate+download in one click feature. It's a bit kludgy but
        // it works
        const blb = new Blob([gencache], { type: "text/plain" });
        if (downloadUrl != undefined && downloadUrl.length > 0) {
            URL.revokeObjectURL(downloadUrl);
        }
        downloadUrl = URL.createObjectURL(blb);

        const alink = document.createElement("a");
        alink.download = getDownloadName(ident, genType);
        alink.href = downloadUrl;
        alink.click();
    }
    const generateContentFile = () => {
        if (!gencache && fileInfo.file) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(fileInfo.file);
            reader.onload = function (evt) {
                console.log("generating content to file");
                gencache = generateHeader(ident, fileInfo, imageDim,imageScale, fontSet, fontSize, fontUnits, genType, evt.target.result);
                setGeneratedFileUrl();
            }
        } else if (gencache) {
            console.log("writing content to file");
            setGeneratedFileUrl();
        }
    }
    const onDropFiles = (e) => {
        e.preventDefault();
        const inputFile = document.getElementById("file");
        inputFile.files = e.dataTransfer.files;
        const fi = { file: e.dataTransfer.files[0], type: e.dataTransfer.files[0].type };
        setFileInfo(fi);
        setIdent(toIdentifier(e.dataTransfer.files[0].name));

        setImageScale(undefined); // set this back so it doesn't accidentally get set to something other than the default
        setFontSize(undefined);
        setFontUnits(undefined);
        setFontSet(undefined);
        if(isSupportedImage(fi)) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(inputFile.files[0]);
            reader.onload = async function (evt) {
                imageDimensions = await readImageDimensions(evt.target.result);
                setImageDim(imageDimensions);
            }
        }
        
        gencache = undefined;
    }
    return (
        <>
            <div id="drop-target" onDrop={onDropFiles} className={"border-drag"} onDragOver={(event) => event.preventDefault()}>
                <p>Select or drag a file here</p>
                <div className="input-group">
                    <table border="0">
                        <tbody>
                            <tr>
                                <td colSpan={2}><input id="file" type="file" onChange={handleFileChange} /></td>
                            </tr>
                            <tr>
                                <td><label>Output:</label></td>
                                <td>
                                    <select id="output" value={genType} onChange={handleTypeChange}>
                                        <option value="C">Raw C/++</option>
                                        <option value="GFX2">GFX 2.x</option>
                                    </select>
                                </td>
                            </tr>
                            <tr>
                                <td><label>Identifier: </label></td><td><input type="text" id="identifier" value={ident} onChange={handleIdentChange} /></td>
                            </tr>
                            {fileInfo && fileInfo.file.name.toLowerCase().endsWith(".fon") && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Set Index: </label></td>
                                    <td>
                                        <input type="text" value={fontSet} onChange={handleFontSetValueChange} onKeyUp={handleFontSetValueChange} />
                                    </td>
                                </tr>
                            )}
                            {fileInfo && isTrueType(fileInfo.file.name) && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Size: </label></td>
                                    <td>
                                        <input type="text" value={fontSize} onChange={handleFontSizeValueChange} onKeyUp={handleFontSizeValueChange} />
                                        <select onChange={handleFontSizeUnitChange} value={fontUnits}>
                                            <option>none</option>
                                            <option value="em">em</option>
                                            <option value="px">px</option>
                                        </select>
                                    </td>
                                </tr>
                            )}
                            {fileInfo && fileInfo.file.type=="image/jpeg" && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Scale: </label></td>
                                    <td>
                                        <select onChange={handleImageScaleChange} value={imageScale}>
                                            <option value="scale_1_1">1:1</option>
                                            <option value="scale_1_2">1:2</option>
                                            <option value="scale_1_4">1:4</option>
                                            <option value="scale_1_8">1:8</option>
                                        </select>
                                    </td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
                {fileInfo && (
                    <section>
                        File details:
                        <ul>
                            {fileInfo.file.type && (
                                <li>MIME: <span className="fileType">{fileInfo.file.type}</span></li>)}
                            {isSupportedImage(fileInfo) && imageDim && (
                                <li>Dimensions: <span className="fileDim">{imageDim.width}x{imageDim.height}</span></li>)}
                            <li>Size: <span className="fileSize">{fileInfo.file.size} bytes</span></li>
                            <li>Type: <span className="genType">{getCreatedTypeName()}</span></li>
                        </ul>

                    </section>
                )}

                {fileInfo && (
                    <>
                        <button onClick={generateContentFile}
                            className="submit"
                        >Download header file</button><br />
                        <button
                            onClick={generateContentClip}
                            className="submit"
                        >Copy to clipboard</button>
                    </>
                )}
            </div><br />
            {fileInfo && (<><h4>Preview</h4></>)}
            {fileInfo && (<SyntaxHighlighter style={a11yDark} language={getGeneratedLanguage(genType)} >{generateHeader(ident, fileInfo, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, undefined)}</SyntaxHighlighter>)}
        </>
    );
};

export default HeaderGenerator;
