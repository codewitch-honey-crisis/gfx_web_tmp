import React, { useState, useRef } from 'react';
import { Light as SyntaxHighlighter } from 'react-syntax-highlighter';
import clang from 'react-syntax-highlighter/dist/esm/languages/hljs/c';
import cpplang from 'react-syntax-highlighter/dist/esm/languages/hljs/cpp';
import { a11yDark, a11yLight } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import { generateStringLiteral, generateByteArrayLiteral, toIdentifier } from './CGen';
import { tvgDimensions, tvgRender, tvgRenderFile, tvgRenderUrl } from './TinyVG'
import { fonLoad, fonMakeGlyph } from './FonFont';
import { vlwLoad, vlwMakeGlyph } from './VlwFont';
import './HeaderGenerator.css';
const isBrowserDarkTheme = () => {
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return true;
    }
    return false;
}
const isText = (fileInfo) => {
    return (fileInfo.type.endsWith("/json") || fileInfo.type.endsWith("/xml") || fileInfo.type.endsWith("+xml") || fileInfo.type.startsWith("text/"));
}
const getIdentifier = (fileInfo) => {
    return toIdentifier(fileInfo.name);
}
const isValidIdentifer = (id) => {
    if(!id || !id.length || id.length===0) {
        return false;
    }
    const re = /^[A-Za-z_][A-Za-z0-9_]*$/;
    const matches = id.match(re);
    return (matches && matches.length>0)
}
const hasFileExt = (fileInfo, cmp) => {
    return fileInfo && (fileInfo.name && fileInfo.name.toLowerCase().endsWith(cmp.toLowerCase()));
}
const isSupportedImage = (fileinfo) => {
    const fileName = fileinfo.name.toLowerCase();
    const fileType = fileinfo.type;
    if (fileType == "image/jpg" || fileType == "image/png" || fileType == "image/svg+xml") {
        return true;
    }
    if (fileName.endsWith(".jpg") || fileName.endsWith(".png") || fileName.endsWith(".svg") || fileName.endsWith(".tvg")) {
        return true;
    }
}
const isSupportedFont = (fileInfo) => {
    return hasFileExt(fileInfo, ".vlw") || hasFileExt(fileInfo, ".fon") ||
        isTrueType(fileInfo);
}
const isRasterFont = (fileInfo) => {
    return fileInfo && fileInfo.name && hasFileExt(fileInfo, ".vlw") || hasFileExt(fileInfo, ".fon");

}
const isTrueType = (fileInfo) => {
    const n = fileInfo.name.toLowerCase();
    return n.endsWith(".ttf") || n.endsWith(".otf");
}
const jpgScaleDim = (dim, scale) => {
    let factor = 1;
    switch (scale) {
        case "scale_1_2":
            factor = .5; break;
        case "scale_1_4":
            factor = .25; break;
        case "scale_1_8":
            factor = .125; break;
        default: // case "scale_1_1": 
            return dim;
    }
    return { width: Math.ceil(dim.width * factor), height: Math.ceil(dim.height * factor) };
}

const toUtf32 = function* (str) {
    for (const character of str) {
        let cp = character.codePointAt(0);
        if (cp >= 0xD800 && cp <= 0xDBFF) { // hi surrogate
            const cpl = character.codePointAt(1);
            if (!(cpl >= 0xDC00 && cpl <= 0xDFFF)) { // not a low surrogate
                throw new Error("Unicode stream error. Unterminated high surrogate");
            }
            const highValue = cp & 1023;
            const lowValue = cpl & 1023;
            const magicAdd = 65536;
            cp = (highValue << 10) | lowValue + magicAdd;
        }
        yield cp;
    }
}
const hasFontSizeAndUnits = (fsize,funits) => {
    if(!fsize || isNaN(fsize) || fsize===0) {
        return false;
    }
    if(!funits || (funits!="px" && funits!="em")) {
        return false;
    }
    return true;
}
const isSpecializedType = (fileInfo, size, units) => {
    if (hasFileExt(fileInfo, ".fon")) {
        return true;
    } else if (fileInfo.type === "image/jpeg") {
        return true;
    } else if (fileInfo.type === "image/png") {
        return true;
    } else if (hasFileExt(fileInfo, ".vlw")) {
        return true;
    } else if (isTrueType(fileInfo) && hasFontSizeAndUnits(size,units)) {
        return true;
    }
    return false;
}
const generateHeader = (identifier, fileInfo, imageDim, imageScale, fontSetIndex, size, units, exposeStream, outputType, data) => {
    let result = "";
    if (imageScale === undefined || imageScale === "") {
        imageScale = "scale_1_1";
    }
    const fileType = fileInfo.type;
    const isGfx = (outputType != undefined && outputType.length > 0 && outputType != "C");
    const guard = identifier.toUpperCase() + ((isGfx) ? "_HPP" : "_H");
    const impl = identifier.toUpperCase() + "_IMPLEMENTATION";
    result += "// Automatically generated by https://honeythecodewitch.com/gfx/header\r\n";
    result += `// #define ${impl} in exactly one\r\n`;
    let tukind = ".c/.cpp";
    if (isGfx) {
        tukind = ".cpp";
    }
    result += `// translation unit (${tukind} file) before including this header\r\n`;
    result += `#ifndef ${guard}\r\n`;
    result += `#define ${guard}\r\n`;
    const istext = isText(fileInfo);
    if (isGfx || !istext) {
        result += "#include <stdint.h>\r\n";
    }

    let imgSize;
    if (imageDim && imageDim.width && imageDim.height && imageDim.width > 0 && imageDim.height > 0) {
        imgSize = imageDim;
    }
    let isSpecialized = false;
    let isFon = false;
    let isTtf = false;
    let isVlw = false;
    let isJpg = false;
    let isPng = false;
    let isSvg = false;
    let isTvg = false;
    let commentPart = isGfx?"constant data stream":"constant source data";
    if (hasFileExt(fileInfo, ".fon")) {
        isFon = true;
        isSpecialized = isFon;
        commentPart = "Windows 3.1 raster font";
    } else if (fileType === "image/jpeg") {
        isJpg = true;
        isSpecialized = true;
        commentPart = "JPEG image";
    } else if (fileType === "image/svg+xml") {
        isSvg = true;
        commentPart = "Scalable Vector Graphic";
    } else if (hasFileExt(fileInfo, ".tvg")) {
        isTvg = true;
        commentPart = "TInyVG binary vector graphic"
    } else if (fileType === "image/png") {
        isPng = true;
        isSpecialized = true;
        commentPart = "PNG image";
    } else if (hasFileExt(fileInfo, ".vlw")) {
        isVlw = true;
        isSpecialized = true;
        commentPart = "Processing antialiased raster font";
    } else if (isTrueType(fileInfo)) {
        if(hasFileExt(".otf")) {
            commentPart = "OpenType vector font";
        } else {
            commentPart = "TrueType vector font";
        }
        if(size && !isNaN(size) && size != 0 && units && units!=="" && units!=="none") {
            isTtf = true;
            isSpecialized = true;
        }
    } else if(isTrueType(fileInfo)) {
        if(hasFileExt(".otf")) {
            commentPart = "OpenType vector font";
        } else {
            commentPart = "TrueType vector font";
        }
    }
    if (isGfx) {
        if (isFon) {
            result += "#include \"gfx_win_font.hpp\"\r\n\r\n";
            result += `/// @brief A ${commentPart}\r\n`;
            result += `extern gfx::win_font ${identifier};\r\n`;
        } else if (isVlw) {
            result += "#include \"gfx_vlw_font.hpp\"\r\n\r\n";
            result += `/// @brief A ${commentPart}\r\n`;
            result += `extern gfx::vlw_font ${identifier};\r\n`;
        } else if (isJpg) {
            result += "#include \"gfx_jpg_image.hpp\"\r\n\r\n";
            if (imgSize) {
                const dim = jpgScaleDim(imgSize, imageScale);
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${dim.width}, ${dim.height}}\r\n\r\n`
            }
            result += `/// @brief A ${commentPart}\r\n`;
            result += `extern gfx::jpg_image ${identifier};\r\n`;
        } else if (isPng) {
            result += "#include \"gfx_png_image.hpp\"\r\n\r\n";
            if (imgSize) {
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += `/// @brief A ${commentPart}\r\n`;
            result += `extern gfx::png_image ${identifier};\r\n`;
        } else if (isTtf) {
            result += "#include \"gfx_ttf_font.hpp\"\r\n\r\n";
            result += `/// @brief A ${commentPart}\r\n`;
            result += `extern gfx::ttf_font ${identifier};\r\n`;
        } else {
            result += "#include \"gfx_core.hpp\"\r\n\r\n";
            if (isSvg || isTvg) {
                if (imgSize) {
                    result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                }
            }
            result += `/// @brief A ${commentPart}\r\n`;
            result += `extern gfx::const_buffer_stream ${identifier};\r\n`;
        }
        if (exposeStream && isSpecialized) {
            result += `/// @brief A ${commentPart} constant source stream\r\n`;
            result += `extern gfx::const_buffer_stream ${identifier}_stream;\r\n`;
        }
    } else {
        if (istext) {
            if (data) {
                const view = new DataView(data);
                result += `#define ${identifier.toUpperCase()}_LENGTH (${view.byteLength})\r\n`;
            } else {
                result += `#define ${identifier.toUpperCase()}_LENGTH (${fileInfo.size})\r\n`;
            }
            if ((isSvg || isTvg || isPng || isJpg) && imgSize) {
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
            result += `/// @brief A ${commentPart}\r\n`;
            result += `const char* ${identifier};\r\n`;
        } else {
            if ((isSvg || isTvg || isPng || isJpg) && imgSize) {
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
            result += `/// @brief A ${commentPart}\r\n`;
            result += `const uint8_t ${identifier}[];\r\n`;
        }
    }
    result += `#endif // ${guard}\r\n\r\n`;
    result += `#ifdef ${impl}\r\n`;
    if (isGfx) {
        if (istext) {
            result += generateStringLiteral(identifier + "_data", data, true) + "\r\n\r\n";
        } else {
            result += generateByteArrayLiteral(identifier + "_data", data, true) + "\r\n\r\n";
        }
        if (isSpecialized && !exposeStream) {
            result += `static gfx::const_buffer_stream ${identifier}_stream\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
        }
        if (isFon) {
            if (fontSetIndex && fontSetIndex != 0) {
                result += `gfx::win_font ${identifier}\r\n    (${identifier}_stream, ${fontSetIndex});\r\n`;
            } else {
                result += `gfx::win_font ${identifier}\r\n    (${identifier}_stream);\r\n`;
            }
        } else if (isVlw) {
            result += `gfx::vlw_font ${identifier}\r\n    (${identifier}_stream);\r\n`;
        } else if (isJpg) {
            if (imageScale && imageScale != "scale_1_1") {
                result += `gfx::jpg_image ${identifier}\r\n    (${identifier}_stream, jpg_scale::${imageScale});\r\n`;
            } else {
                result += `gfx::jpg_image ${identifier}\r\n    (${identifier}_stream);\r\n`;
            }
        } else if (isPng) {
            result += `gfx::png_image ${identifier}\r\n    (${identifier}_stream);\r\n`;
        } else if (isTtf) {
            result += `gfx::ttf_font ${identifier}\r\n    (${identifier}_stream, ${size}, gfx::font_size_units::${units})\r\n`;
        } else {
            if (istext) {
                if (data) {
                    const view = new DataView(data);
                    result += `gfx::const_buffer_stream ${identifier}\r\n    ((const uint8_t*)${identifier}_data, ${view.byteLength});\r\n`;
                } else {
                    result += `gfx::const_buffer_stream ${identifier}\r\n    ((const uint8_t*)${identifier}_data, ${fileInfo.size});\r\n`;
                }
            } else {
                result += `gfx::const_buffer_stream ${identifier}\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
            }
        }
        if (isSpecialized && exposeStream) {
            result += `gfx::const_buffer_stream ${identifier}_stream\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
        }
    } else {
        if (istext) {
            result += generateStringLiteral(identifier, data, false) + "\r\n";
        } else {
            result += generateByteArrayLiteral(identifier, data, false) + "\r\n";
        }
    }
    result += `#endif // ${impl}\r\n`;
    return result;
}
const getDownloadName = (ident, genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return `${ident}.h`;
    }
    return `${ident}.hpp`;
}
const getGeneratedLanguage = (genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return "c";
    }
    return "cpp";
}
const HeaderGenerator = () => {
    SyntaxHighlighter.registerLanguage('c', clang);
    SyntaxHighlighter.registerLanguage('cpp', cpplang);

    let gencache;
    let gentype;
    let stm;
    let imageDimensions;
    let fontLineHeight;
    let idnt;
    let fsize;
    let fset;
    let funits;
    let iscale;
    let invfonidx;
    const [syntaxTheme, setSyntaxTheme] = useState(isBrowserDarkTheme() ? a11yDark : a11yLight);

    function useForceUpdate() {
        setSyntaxTheme(isBrowserDarkTheme() ? a11yDark : a11yLight)
    }

    const fileInfo = useRef("");
    const fileCache = useRef(undefined);
    const downloadUrl = useRef("");
    const [invalidFonIndex,setInvalidFonIndex] = useState(false);
    const [ident, setIdent] = useState("");
    const [fontSet, setFontSet] = useState(0);
    const [fontHeight, setFontHeight] = useState(0);
    const [fontSize, setFontSize] = useState(0);
    const [fontUnits, setFontUnits] = useState("none");
    const [imageScale, setImageScale] = useState("scale_1_1");
    const [imageDim, setImageDim] = useState("");
    const [genType, setGenType] = useState("C");
    const [exposeStream, setExposeStream] = useState(false);


    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
        useForceUpdate();
    });
    const prepareNewFile = (file) => {
        fileCache.current = undefined;
        fileInfo.current = file;
        setIdent(getIdentifier(file));
        // setImageScale(undefined); // set this back so it doesn't accidentally get set to something other than the default
        // setFontSize(undefined);
        // setFontUnits(undefined);
        // setFontSet(undefined);
        gencache = undefined;
        return file;
    }

    const handleFileChange = (e) => {
        if(e.target.files.length===0) {
            return;
        }
        const fi = prepareNewFile(e.target.files[0]);
        if (isSupportedImage(fi) ||
            isSupportedFont(fi)
        ) {
            if (fileCache.current) {
                previewFile();
                return;
            }
            let reader = new FileReader();
            reader.onload = async function (evt) {
                fileCache.current = evt.target.result;
                previewFile();
            };
            reader.readAsArrayBuffer(e.target.files[0]);
        }

    };
    const handleIdentChange = (e) => {
        if (ident != e.target.value) {
            idnt = e.target.value;
            setIdent(idnt);
            gencache = undefined;
        }
    }
    const handleFontSetValueChange = (e) => {
        let n;
        if(e.target.value.length>0) {
            n = Number.parseInt(e.target.value);
            if (isNaN(n)) {
                n = 0;
            }
        } else {
            n=0;
        }
        fset = n;
        setInvalidFonIndex(false);
        setFontSet(fset);
        gencache = undefined;
        previewFile();
    }
    const handleImageScaleChange = (e) => {
        let s = e.target.value;
        if (s === undefined || s === "") {
            s = "scale_1_1";
        }
        iscale = s;
        setImageScale(s);
        gencache = undefined;
        previewFile();
    }
    const handleFontSizeValueChange = (e) => {
        let n = Number.parseFloat(e.target.value);
        fsize = n;
        setFontSize(n);
        gencache = undefined;
        previewFile();
    }
    const handleFontSizeUnitChange = (e) => {
        funits = e.target.value;
        if(!funits) {
            funits = "none";
        }
        setFontUnits(funits);
        gencache = undefined;
        previewFile();
    }
    const handleTypeChange = (e) => {
        gentype = e.target.value;
        setGenType(gentype);
        iscale = "scale_1_1";
        setImageScale(iscale);
        gencache = undefined;
        previewFile();
    }
    const handleStreamChange = (e) => {
        stm = e.target.checked;
        setExposeStream(stm);
        gencache = undefined;
    }
    const readImageDimensions = async (data, isSvg = false) => {
        return new Promise((resolve, reject) => {
            if (!isSvg) {
                let dim = tvgDimensions(data);
                if (dim) {
                    resolve(dim);
                }
                else {
                    const imgsrc = URL.createObjectURL(new Blob([data]));
                    const img = new Image();
                    img.onload = () => {
                        dim = {
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        };
                        resolve(dim);
                    };
                    img.src = imgsrc;
                }
            } else {
                let decoder = new TextDecoder('utf-8');
                const svgstr = decoder.decode(data);
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgstr, 'image/svg+xml');
                const svg = doc.documentElement;

                // Get bounding box of all content
                document.body.appendChild(svg);
                let dim;
                let w=svg.getAttributeNS(null,"width");
                let h=svg.getAttributeNS(null,"height");
                if(w && h && w.length>0 && h.length>0) {
                    dim = {
                        width: Math.ceil(parseFloat(w)),
                        height: Math.ceil(parseFloat(h))
                    };
                } else {
                    const bbox = svg.getBBox();
                    dim = {
                        width: Math.ceil(bbox.width + bbox.x),
                        height: Math.ceil(bbox.height + bbox.y)
                    };
                }
                
                document.body.removeChild(svg);
                
                if (dim && dim.width > 0) {
                    resolve(dim);
                } else {
                    reject();
                }
            }
        });
    }
    
    const getCreatedTypeName = () => {
        if (fileInfo.current) {
            if (!genType || genType === "" || genType === "C") {
                if (isText(fileInfo.current)) {
                    return "const char*";
                } else {
                    return "const uint8_t[]";
                }
            }
            const fileType = fileInfo.current.type;
            const fileName = fileInfo.current.name;
            const size = fontSize;
            const units = fontUnits;
            if (fileType === undefined || fileType === "" && hasFileExt(fileInfo.current, ".fon")) {
                return "gfx::win_font";
            } else if (fileType === "image/jpeg") {
                return "gfx::jpg_image";
            } else if (fileType === "image/png") {
                return "gfx::png_image";
            } else if (hasFileExt(fileInfo.current, ".vlw")) {
                return "gfx::vlw_font";
            } else if (isTrueType(fileInfo.current) && size && !isNaN(size) && size != 0 && units) {
                return "gfx::ttf_font";
            }

            return "gfx::const_buffer_stream";

        }
        return undefined;
    }

    const generateContentClip = () => {
        if (!gencache && fileInfo.current) {
            let reader = new FileReader();
            reader.onload = async function (evt) {
                console.log("generating content to clipboard");
                gencache = generateHeader(ident, fileInfo.current, imageDim, imageScale, fontSet, fontSize, fontUnits, exposeStream, genType, evt.target.result);
                await navigator.clipboard.writeText(gencache);
            }
            reader.readAsArrayBuffer(fileInfo.current);
        } else if (gencache) {
            console.log("writing content to clipboard");
            navigator.clipboard.writeText(gencache);
        }
    }
    const setGeneratedFileUrl = () => {
        // this is a hack. alink must be created outside React's normal rendering sequence
        // due to the on the fly generate+download in one click feature. It's a bit kludgy but
        // it works
        const blb = new Blob([gencache], { type: "text/plain" });
        if (downloadUrl.current != undefined && downloadUrl.current.length > 0) {
            URL.revokeObjectURL(downloadUrl.current);
            downloadUrl.current = "";
        }
        downloadUrl.current = URL.createObjectURL(blb);

        const alink = document.createElement("a");
        alink.download = getDownloadName(ident, genType);
        alink.href = downloadUrl.current;
        alink.click();
        setTimeout(() => { if (downloadUrl.current && downloadUrl.current.length > 0) { URL.revokeObjectURL(downloadUrl.current), downloadUrl.current = ""; } }, 500);
    }
    const revokePicture = () => {
        setTimeout(function () { try { URL.revokeObjectURL(document.getElementById("picture").src); } catch { console.log("couldn't revoke url"); } }, 1000);
    }

    const generateContentFile = () => {
        if (!gencache && fileInfo.current) {
            let reader = new FileReader();
            reader.onload = function (evt) {
                console.log("generating content to file");
                gencache = generateHeader(ident, fileInfo.current, imageDim, imageScale, fontSet, fontSize, fontUnits, exposeStream, genType, evt.target.result);
                setGeneratedFileUrl();
            }
            reader.readAsArrayBuffer(fileInfo.current);
            
        } else if (gencache) {
            console.log("writing content to file");
            setGeneratedFileUrl();
        }
    }
    const drawFonString = (cvsctx, fon, str, x, y, col) => {
        let xo = 0;
        let yo = 0;
        for (let i = 0; i < str.length; ++i) {
            if (str.charCodeAt(i) === '\r'.charCodeAt(0)) {
                xo = 0;
            } else if (str.charCodeAt(i) === '\n'.charCodeAt(0)) {
                yo += fon.lineHeight;
                xo = 0;
            } else {
                const ch = str.charCodeAt(i);
                const glyph = fonMakeGlyph(fon, ch, col);
                if (glyph && glyph.width) {
                    const data = new Uint8ClampedArray(glyph.data);
                    const image = new ImageData(data, glyph.width, glyph.height);
                    cvsctx.putImageData(image, xo + x, yo + y);
                    xo += glyph.width;
                } else {
                    xo += fon.width;
                }
            }

        }
    }
    const drawVlwString = (cvsctx, vlw, str, x, y, col) => {
        let xo = 0;
        let yo = 0;
        for (const cp of toUtf32(str)) {
            if (cp === '\r'.charCodeAt(0)) {
                xo = 0;
            } else if (cp === '\n'.charCodeAt(0)) {
                yo += vlw.lineHeight;
                xo = 0;
            } else {
                const glyph = vlwMakeGlyph(vlw, cp, col);
                if (glyph && glyph.width) {
                    const data = new Uint8ClampedArray(glyph.data);
                    const image = new ImageData(data, glyph.width, glyph.height);
                    cvsctx.putImageData(image, xo + x + glyph.offset.x, yo + y + glyph.offset.y);
                    xo += glyph.advWidth;
                } else {
                    xo += vlw.spaceWidth;
                }
            }
        }
    }
    const previewFile = () => {
        if ((!fileInfo.current) || (!fileCache.current)) {
            console.log("No gen info");
            return;
        }
        let fcache = fileCache.current;

        const finfo = fileInfo.current;
        if (!fsize) {
            fsize = fontSize;
        }
        if (!funits) {
            funits = fontUnits;
        }
        if (!iscale) {
            iscale = imageScale;
        }
        if (!fset) {
            fset = fontSet;
        }
        if (!gentype) {
            if (!genType) {
                gentype = "C";
            } else {
                gentype = genType;
            }
        }
        if (isSupportedImage(finfo)) {
            if (hasFileExt(fileInfo.current, ".tvg")) {
                tvgRender("tinyvg", fcache);
                const pic = document.getElementById("tinyvg");
                readImageDimensions(fcache, false).then((value) => {
                    imageDimensions = value;
                    setImageDim(imageDimensions);
                    let w = imageDimensions.width;
                    let h = imageDimensions.height;
                    pic.style = `width: ${w}px; height: ${h}px`;
                });
            } else if (hasFileExt(fileInfo.current, ".svg")) {
                const pic = document.getElementById("svgContainer");
                if (!pic) {
                    console.log("Could not find svg container");
                } else {
                    const decoder = new TextDecoder();
                    const str = decoder.decode(fcache);
                    pic.innerHTML = str;
                    readImageDimensions(fcache, true).then((value) => {
                        imageDimensions = value;
                        setImageDim(imageDimensions);
                        let w = imageDimensions.width;
                        let h = imageDimensions.height;
                        pic.style = `width: ${w}px; height: ${h}px`;
                    });
                }
            } else {
                const pic = document.getElementById("picture");
                if (!pic) {
                    console.log("Could not find picture");
                } else {
                    const blb = new Blob([fcache]);
                    const url = URL.createObjectURL(blb);
                    pic.src = url;
                    readImageDimensions(fcache, hasFileExt(fileInfo.current, ".svg")).then((value) => {
                        imageDimensions = value;
                        setImageDim(imageDimensions);
                        let w = imageDimensions.width;
                        let h = imageDimensions.height;
                        if (hasFileExt(fileInfo.current, ".jpg") && iscale) {
                            if (gentype && gentype.startsWith("G")) {
                                const dim = jpgScaleDim({ width: w, height: h }, iscale);
                                w = dim.width;
                                h = dim.height;
                            }
                        }
                        pic.width = w;
                        pic.height = h;
                    });

                }
            }
        } else if (hasFileExt(fileInfo.current, ".fon")) {

            let fon;
            const cvs = document.getElementById("rasterFont");
            if (!cvs) {
                console.log("Couldn't find font canvas");
                return;
            }
            try {
                fon = fonLoad(fcache, fset);
                invfonidx = false;
                setInvalidFonIndex(false);
            }
            catch {
                console.log("Couldn't load font");
                const ctx = cvs.getContext("2d");
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                invfonidx = true;
                setInvalidFonIndex(true);
                return;
            }
            fontLineHeight = fon.lineHeight;
            setFontHeight(fontLineHeight);

            cvs.width = cvs.offsetWidth;
            cvs.height = cvs.offsetHeight;

            const ctx = cvs.getContext("2d");
            ctx.clearRect(0, 0, cvs.width, cvs.height);

            drawFonString(ctx, fon,
                "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz", 0, 0, 0xFF0FF0FF);

        } else if (hasFileExt(fileInfo.current, ".vlw")) {
            const vlw = vlwLoad(fcache);
            fontLineHeight = vlw.lineHeight;
            setFontHeight(fontLineHeight);
            const cvs = document.getElementById("rasterFont");
            if (!cvs) {
                console.log("Couldn't find font canvas");
            } else {
                cvs.width = cvs.offsetWidth;
                cvs.height = cvs.offsetHeight;
                const ctx = cvs.getContext("2d");
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                drawVlwString(ctx, vlw,
                    "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz", 0, 0, 0xFF0FF0FF);
            }
        } else if (isTrueType(fileInfo.current)) {
            const spn = document.getElementById("vectorFont");
            if (!spn) {
                console.log("Couldn't find font container");
            } else {
                const blb = new Blob([fcache]);
                if (!idnt) {
                    idnt = ident;
                }
                if (!idnt) {
                    idnt = getIdentifier(fileInfo.current);
                }
                const fnturl = URL.createObjectURL(blb);
                const fnt = new FontFace(idnt, `url(${fnturl})`);
                fnt.load().then(() => {
                    document.fonts.add(fnt);
                    URL.revokeObjectURL(fnturl);
                    if(!gentype.startsWith("G") || !hasFontSizeAndUnits(fsize,funits)) {
                        fsize = 2;
                        funits="em";
                    }
                    spn.innerHTML = `<pre style="font: ${fsize}${funits} ${idnt}; color: #FF0FF0;">` +
                        "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz".replace(/[\u00A0-\u9999<>\&]/g, i => '&#' + i.charCodeAt(0) + ';') +
                        "</pre>";
                });
            }
        }
    }

    const handleDropFiles = (e) => {
        e.preventDefault();
        const inputFile = document.getElementById("file");
        inputFile.files = e.dataTransfer.files;
        const fi = prepareNewFile(e.dataTransfer.files[0]);
        if (isSupportedImage(fi) ||
            isSupportedFont(fi)
        ) {
            if (fileCache.current) {
                previewFile();
                return;
            }
            let reader = new FileReader();
            reader.onload = async function (evt) {
                fileCache.current = evt.target.result;
                previewFile();
            };
            reader.readAsArrayBuffer(e.dataTransfer.files[0]);
        }
    }
    return (
        <>
            <div id="drop-target" onDrop={handleDropFiles} className={"border-drag"} onDragOver={(event) => event.preventDefault()}>
                {!fileInfo.current && (<p>Select or drag a file here</p>)}
                <div className="input-group">
                    <table border="0">
                        <tbody>
                            <tr>
                                <td colSpan={2}><input id="file" type="file" onChange={handleFileChange} /></td>
                            </tr>
                            {fileInfo.current && (<>
                                <tr>
                                    <td><label>Output:</label></td>
                                    <td>
                                        <select id="output" defaultValue={genType} onChange={handleTypeChange}>
                                            <option value="C">Raw C/++</option>
                                            <option value="GFX2">GFX 2.x</option>
                                        </select>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label>Identifier: </label></td><td><input type="text" id="identifier" value={ident} onChange={handleIdentChange} /></td>
                                </tr>
                                {hasFileExt(fileInfo.current, ".fon") && genType.startsWith("G") && (
                                    <tr>
                                        <td><label>Set Index: </label></td>
                                        <td>
                                            <input type="text" onChange={handleFontSetValueChange} />
                                        </td>
                                    </tr>
                                )}
                                {isTrueType(fileInfo.current) && genType.startsWith("G") && (
                                    <tr>
                                        <td><label>Size: </label></td>
                                        <td>
                                            <input type="text" onChange={handleFontSizeValueChange} />
                                            <select onChange={handleFontSizeUnitChange}>
                                                <option value="none">none</option>
                                                <option value="em">em</option>
                                                <option value="px">px</option>
                                            </select>
                                        </td>
                                    </tr>
                                )}
                                {isSpecializedType(fileInfo.current, fontSize, fontUnits) && genType.startsWith("G") && (
                                    <tr>
                                        <td><label>Stream: </label></td>
                                        <td>
                                            <input type="checkbox" onChange={handleStreamChange} />
                                        </td>
                                    </tr>
                                )}
                                {fileInfo.current.type == "image/jpeg" && genType.startsWith("G") && (
                                    <tr>
                                        <td><label>Scale: </label></td>
                                        <td>
                                            <select onChange={handleImageScaleChange}>
                                                <option value="scale_1_1">1:1</option>
                                                <option value="scale_1_2">1:2</option>
                                                <option value="scale_1_4">1:4</option>
                                                <option value="scale_1_8">1:8</option>
                                            </select>
                                        </td>
                                    </tr>
                                )}
                            </>)}
                        </tbody>
                    </table>
                </div>
                {fileInfo.current && (
                    <section>
                        File details:
                        <ul>
                            {fileInfo.current.type && (
                                <li>MIME: <span className="fileType">{fileInfo.current.type}</span></li>)}
                            {isSupportedImage(fileInfo.current) && imageDim && (
                                <li>Dimensions: <span className="fileDim">{imageDim.width}x{imageDim.height}</span></li>)}
                            {isRasterFont(fileInfo.current) && fontHeight > 0 && (
                                <li>Line Height: <span className="fontHeight">{fontHeight}</span></li>)}
                            <li>Size: <span className="fileSize">{fileInfo.current.size} bytes</span></li>
                            <li>Type: <span className="genType">{getCreatedTypeName()}</span></li>

                        </ul>

                    </section>
                )}

                {fileInfo.current && (<>
                    {isValidIdentifer(ident) && (!hasFileExt(fileInfo.current, ".fon") || invalidFonIndex===false) && (
                        <>
                            <button onClick={generateContentFile}
                                className="submit"
                            >Download header file</button><br />
                            <button
                                onClick={generateContentClip}
                                className="submit"
                            >Copy to clipboard</button>
                        </>)
                    }
                    {!isValidIdentifer(ident) && (
                        <>
                            <span style={{color: "red"}}>Error: Invalid identifier</span>
                        </>
                    )}
                    {(hasFileExt(fileInfo.current, ".fon") && invalidFonIndex) && (
                        <>
                            <span style={{color: "red"}}>Error: Invalid font index</span>
                        </>
                    )}</>
                )}
            </div><br />
            {fileInfo.current && (<><h4>Preview</h4></>)}
            {fileInfo.current && (<>
                {isValidIdentifer(ident) && (<SyntaxHighlighter style={syntaxTheme} language={getGeneratedLanguage(genType)}>{generateHeader(ident, fileInfo.current, imageDim, imageScale, fontSet, fontSize, fontUnits, exposeStream, genType, undefined)}</SyntaxHighlighter>)}
                {hasFileExt(fileInfo.current, ".tvg") && (<svg id="tinyvg" xmlns="http://www.w3.org/2000/svg"></svg>)}
                {!hasFileExt(fileInfo.current, ".tvg") && !hasFileExt(fileInfo.current, ".svg") && isSupportedImage(fileInfo.current) && (<img id="picture" onLoad={revokePicture()} />)}
                {hasFileExt(fileInfo.current, ".svg") && isSupportedImage(fileInfo.current) && (<div id="svgContainer" />)}
                {(hasFileExt(fileInfo.current, ".fon") || hasFileExt(fileInfo.current, ".vlw")) && (<canvas id="rasterFont" width={800} height={300} style={{ width: "%100", height: "100%" }} />)}
                {isTrueType(fileInfo.current) && (<span id="vectorFont" style={{ width: "800px", height: "300px" }} />)}
            </>)}
        </>
    );
};

export default HeaderGenerator;
