import React, { useState, useRef } from 'react';
import { Light as SyntaxHighlighter } from 'react-syntax-highlighter';
import clang from 'react-syntax-highlighter/dist/esm/languages/hljs/c';
import cpplang from 'react-syntax-highlighter/dist/esm/languages/hljs/cpp';
import { a11yDark,a11yLight } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import { generateStringLiteral, generateByteArrayLiteral, toIdentifier } from './CGen';
import { tvgDimensions, tvgRender } from './TinyVG'
import { fonLoad, fonMakeGlyph } from './FonFont';
import { vlwLoad, vlwMakeGlyph } from './VlwFont';
import './HeaderGenerator.css';

SyntaxHighlighter.registerLanguage('c', clang);
SyntaxHighlighter.registerLanguage('cpp', cpplang);

const HeaderGenerator = () => {
    let downloadUrl = "";
    var gencache;
    var gentype;
    var imageDimensions;
    var fontLineHeight;
    var idnt;
    var fsize;
    var fset;
    var funits;
    var iscale;
    const isBrowserDarkTheme = () => {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return true;
        }
        return false;
    }
    const [syntaxTheme, setSyntaxTheme] = useState(isBrowserDarkTheme()?a11yDark:a11yLight);
    
    function useForceUpdate(){
        setSyntaxTheme(isBrowserDarkTheme()? a11yDark:a11yLight)
        // A function that increment 👆🏻 the previous state like here 
        // is better than directly setting `setValue(value + 1)`
    }
    
    const fileInfo = useRef("");
    const fileCache = useRef(undefined);
    const [ident, setIdent] = useState("");
    const [fontSet, setFontSet] = useState(0);
    const [fontHeight, setFontHeight] = useState(0);
    const [fontSize, setFontSize] = useState(0);
    const [fontUnits, setFontUnits] = useState("em");
    const [imageScale, setImageScale] = useState("scale_1_1");
    const [imageDim, setImageDim] = useState("");
    const [genType, setGenType] = useState("C");
    
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
        useForceUpdate();
    });
    
    const isText = (type) => {
        return (type.endsWith("/json") || type.endsWith("/xml") || type.endsWith("+xml") || type.startsWith("text/"));
    }
    const isFileExt = (name,cmp) => {
        return (name && name.toLowerCase().endsWith(cmp.toLowerCase()));
    }
    const isSupportedImage = (fileinfo) => {
        const fileName = fileinfo.file.name.toLowerCase();
        const fileType = fileinfo.file.type;
        if (fileType == "image/jpg" || fileType == "image/png" || fileType == "image/svg+xml") {
            return true;
        }
        if (fileName.endsWith(".jpg") || fileName.endsWith(".png") || fileName.endsWith(".svg") || fileName.endsWith(".tvg")) {
            return true;
        }
    }
    const isSupportedFont = (fileInfo) => {
        return isFileExt(fileInfo.file.name,".vlw") || isFileExt(fileInfo.file.name,".fon") ||
            isTrueType(fileInfo.file.name);
    }
    const jpgScaleDim = (dim, scale) => {
        let factor = 1;
        switch (scale) {
            case "scale_1_2":
                factor = .5; break;
            case "scale_1_4":
                factor = .25; break;
            case "scale_1_8":
                factor = .125; break;
            default: // case "scale_1_1": 
                return dim;
        }
        return { width: Math.ceil(dim.width * factor), height: Math.ceil(dim.height * factor) };
    }

    const isTrueType = (name) => {
        const n = name.toLowerCase();
        return n.endsWith(".ttf") || n.endsWith(".otf");
    }

    const generateHeader = (identifier, fileInfo, imageDim, imageScale, fontSetIndex, size, units, outputType, data) => {
        let result = "";
        if (imageScale === undefined || imageScale === "") {
            imageScale = "scale_1_1";
        }
        const fileName = fileInfo.file.name;
        const fileType = fileInfo.file.type;
        const isGfx = (outputType != undefined && outputType.length > 0 && outputType != "C");
        const guard = identifier.toUpperCase() + ((isGfx) ? "_HPP" : "_H");
        const impl = identifier.toUpperCase() + "_IMPLEMENTATION";
        result += "// Automatically generated by https://honeythecodewitch.com/gfx/header\r\n";
        result += `// #define ${impl} in exactly one\r\n`;
        let tukind = ".c/.cpp";
        if (isGfx) {
            tukind = ".cpp";
        }
        result += `// translation unit (${tukind} file) before including this header\r\n`;
        result += `#ifndef ${guard}\r\n`;
        result += `#define ${guard}\r\n`;
        const istext = isText(fileType);
        if (isGfx || !istext) {
            result += "#include <stdint.h>\r\n";
        }

        var imgSize;
        if (imageDim && imageDim.width && imageDim.height && imageDim.width > 0 && imageDim.height > 0) {
            imgSize = imageDim;
        }
        let isSpecialized = false;
        let isFon = false;
        let isTtf = false;
        let isVlw = false;
        let isJpg = false;
        let isPng = false;
        let isSvg = false;
        let isTvg = false;
        if (fileType === undefined || fileType === "" && fileName.toLowerCase().endsWith(".fon")) {
            isFon = true;
            isSpecialized = isFon;
        } else if (fileType === "image/jpeg") {
            isJpg = true;
            isSpecialized = true;
        } else if (fileType === "image/svg+xml") {
            isSvg = true;
        } else if (isFileExt(fileName,".tvg")) {
            isTvg = true;
        } else if (fileType === "image/png") {
            isPng = true;
            isSpecialized = true;
        } else if (isFileExt(fileName,".vlw")) {
            isVlw = true;
            isSpecialized = true;
        } else if (isTrueType(fileName) && size && !isNaN(size) && size != 0 && units) {
            isTtf = true;
            isSpecialized = true;
        }
        if (isGfx) {
            if (isFon) {
                result += "#include \"gfx_win_font.hpp\"\r\n\r\n";
                result += `extern gfx::win_font ${identifier};\r\n`;
            } else if (isVlw) {
                result += "#include \"gfx_vlw_font.hpp\"\r\n\r\n";
                result += `extern gfx::vlw_font ${identifier};\r\n`;
            } else if (isJpg) {
                result += "#include \"gfx_jpg_image.hpp\"\r\n\r\n";
                if (imgSize) {
                    const dim = jpgScaleDim(imgSize, imageScale);
                    result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${dim.width}, ${dim.height}}\r\n\r\n`
                }
                result += `extern gfx::jpg_image ${identifier};\r\n`;
            } else if (isPng) {
                result += "#include \"gfx_png_image.hpp\"\r\n\r\n";
                if (imgSize) {
                    result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                }
                result += `extern gfx::png_image ${identifier};\r\n`;
            } else if (isTtf) {
                result += "#include \"gfx_ttf_font.hpp\"\r\n\r\n";
                result += `extern gfx::ttf_font ${identifier};\r\n`;
            } else {
                result += "#include \"gfx_core.hpp\"\r\n\r\n";
                if (isSvg || isTvg) {
                    if (imgSize) {
                        result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                    }
                }
                result += `extern gfx::const_buffer_stream ${identifier};\r\n`;
            }
        } else {
            if (istext) {
                if (data) {
                    const view = new DataView(data);
                    result += `#define ${identifier.toUpperCase()}_LENGTH (${view.byteLength})\r\n`;
                } else {
                    result += `#define ${identifier.toUpperCase()}_LENGTH (${fileInfo.file.size})\r\n`;
                }
                if ((isSvg || isTvg || isPng || isJpg) && imgSize) {
                    result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                }
                result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
                result += `const char* ${identifier};\r\n`;
            } else {
                if ((isSvg || isTvg || isPng || isJpg) && imgSize) {
                    result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                }
                result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
                result += `const uint8_t ${identifier}[];\r\n`;
            }
        }
        result += `#endif // ${guard}\r\n\r\n`;
        result += `#ifdef ${impl}\r\n`;
        if (isGfx) {
            if (istext) {
                result += generateStringLiteral(identifier + "_data", data, true) + "\r\n\r\n";
            } else {
                result += generateByteArrayLiteral(identifier + "_data", data, true) + "\r\n\r\n";
            }
            if (isSpecialized) {
                result += `static gfx::const_buffer_stream ${identifier}_stream\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
            }
            if (isFon) {
                if (fontSetIndex && fontSetIndex != 0) {
                    result += `gfx::win_font ${identifier}\r\n    (${identifier}_stream, ${fontSetIndex});\r\n`;
                } else {
                    result += `gfx::win_font ${identifier}\r\n    (${identifier}_stream);\r\n`;
                }
            } else if (isVlw) {
                result += `gfx::vlw_font ${identifier}\r\n    (${identifier}_stream);\r\n`;
            } else if (isJpg) {
                if (imageScale && imageScale != "scale_1_1") {
                    result += `gfx::jpg_image ${identifier}\r\n    (${identifier}_stream, jpg_scale::${imageScale});\r\n`;
                } else {
                    result += `gfx::jpg_image ${identifier}\r\n    (${identifier}_stream);\r\n`;
                }
            } else if (isPng) {
                result += `gfx::png_image ${identifier}\r\n    (${identifier}_stream);\r\n`;
            } else if (isTtf) {
                result += `gfx::ttf_font ${identifier}\r\n    (${identifier}_stream, ${size}, gfx::font_size_units::${units})\r\n`;
            } else {
                if (istext) {
                    if (data) {
                        const view = new DataView(data);
                        result += `gfx::const_buffer_stream ${identifier}\r\n    ((const uint8_t*)${identifier}_data, ${view.byteLength});\r\n`;
                    } else {
                        result += `gfx::const_buffer_stream ${identifier}\r\n    ((const uint8_t*)${identifier}_data, ${fileInfo.file.size});\r\n`;
                    }
                } else {
                    result += `gfx::const_buffer_stream ${identifier}\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
                }
            }
        } else {
            if (istext) {
                result += generateStringLiteral(identifier, data, false) + "\r\n";
            } else {
                result += generateByteArrayLiteral(identifier, data, false) + "\r\n";
            }
        }
        result += `#endif // ${impl}\r\n`;
        return result;
    }
    const getDownloadName = (ident, genType) => {
        if (genType === "C" || genType === undefined || genType === "") {
            return `${ident}.h`;
        }
        return `${ident}.hpp`;
    }
    const getGeneratedLanguage = (genType) => {
        if (genType === "C" || genType === undefined || genType === "") {
            return "c";
        }
        return "cpp";
    }
    const handleFileChange = (e) => {
        fileInfo.current=({ file: e.target.files[0], type: e.target.files[0].type });
        setIdent(toIdentifier(e.target.files[0].name));
        gencache = undefined;
    };
    const handleIdentChange = (e) => {
        if (ident != e.target.value) {
            idnt = e.target.value;
            setIdent(idnt);
            gencache = undefined;
        }
    }
    const handleFontSetValueChange = (e) => {
        let n = Number.parseInt(e.target.value);
        if (isNaN(n)) {
            n = 0;
        }
        fset = n;
        setFontSet(fset);
        gencache = undefined;
        previewFile();
    }
    const handleImageScaleChange = (e) => {
        let s = e.target.value;
        if (s === undefined || s === "") {
            s = "scale_1_1";
        }
        iscale = s;
        setImageScale(s);
        gencache = undefined;
        previewFile();
    }
    const handleFontSizeValueChange = (e) => {
        let n = Number.parseFloat(e.target.value);
        if (isNaN(n)) {
            n = 0;
        }
        fsize = n;
        setFontSize(n);
        gencache = undefined;
        previewFile();
    }
    const handleFontSizeUnitChange = (e) => {
        let u = e.target.value;
        if (u === "none" || u === undefined || u === "") {
            setFontSize(0);
            setFontUnits(u);
            gencache = undefined;
            previewFile();
            return;
        }
        if (u != "em" && u != "px") {
            u = "em";
        }
        funits = u;
        fsize = 0;
        setFontUnits(u);
        gencache = undefined;
        previewFile();
    }
    const handleTypeChange = (e) => {
        gentype = e.target.value;
        setGenType(gentype);
        iscale = "scale_1_1";
        setImageScale(iscale);
        gencache = undefined;
        previewFile();
    }

    const readImageDimensions = async (data, isSvg = false) => {
        return new Promise((resolve, reject) => {
            if (!isSvg) {
                let dim = tvgDimensions(data);
                if (dim) {
                    resolve(dim);
                }
                else {
                    const imgsrc = URL.createObjectURL(new Blob([data]));
                    const img = new Image();
                    img.onload = () => {
                        dim = {
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        };
                        resolve(dim);
                    };
                    img.src = imgsrc;
                }
            } else {
                var decoder = new TextDecoder('utf-8');
                const svgstr = decoder.decode(data);
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgstr, 'image/svg+xml');
                const svg = doc.documentElement;

                // Get bounding box of all content
                document.body.appendChild(svg);
                const bbox = svg.getBBox();
                document.body.removeChild(svg);
                const dim = {
                    width: Math.ceil(bbox.width + bbox.x),
                    height: Math.ceil(bbox.height + bbox.y)
                };
                if (dim && dim.width > 0) {
                    resolve(dim);
                } else {
                    reject();
                }
            }
        });
    }
    const getCreatedTypeName = () => {
        if (fileInfo.current) {
            if (!genType || genType === "" || genType === "C") {
                if (isText(fileInfo.current.type)) {
                    return "const char*";
                } else {
                    return "const uint8_t[]";
                }
            }
            const fileType = fileInfo.current.type;
            const fileName = fileInfo.current.file.name;
            const size = fontSize;
            const units = fontUnits;
            if (fileType === undefined || fileType === "" && isFileExt(fileName,".fon")) {
                return "gfx::win_font";
            } else if (fileType === "image/jpeg") {
                return "gfx::jpg_image";
            } else if (fileType === "image/png") {
                return "gfx::png_image";
            } else if (isFileExt(fileName,".vlw")) {
                return "gfx::vlw_font";
            } else if (isTrueType(fileName) && size && !isNaN(size) && size != 0 && units) {
                return "gfx::ttf_font";
            }

            return "gfx::const_buffer_stream";

        }
        return undefined;
    }

    const generateContentClip = () => {
        if (!gencache && fileInfo.current.file) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(fileInfo.current.file);
            reader.onload = async function (evt) {
                console.log("generating content to clipboard");
                gencache = generateHeader(ident, fileInfo.current, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, evt.target.result);
                await navigator.clipboard.writeText(gencache);
            }
        } else if (gencache) {
            console.log("writing content to clipboard");
            navigator.clipboard.writeText(gencache);
        }
    }
    const setGeneratedFileUrl = () => {
        // this is a hack. alink must be created outside React's normal rendering sequence
        // due to the on the fly generate+download in one click feature. It's a bit kludgy but
        // it works
        const blb = new Blob([gencache], { type: "text/plain" });
        if (downloadUrl != undefined && downloadUrl.length > 0) {
            URL.revokeObjectURL(downloadUrl);
        }
        downloadUrl = URL.createObjectURL(blb);

        const alink = document.createElement("a");
        alink.download = getDownloadName(ident, genType);
        alink.href = downloadUrl;
        alink.click();
    }
    const revokePicture = () => {
        setTimeout(function () { URL.revokeObjectURL(document.getElementById("picture").src); }, 10000);
    }

    const generateContentFile = () => {
        if (!gencache && fileInfo.current.file) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(fileInfo.current.file);
            reader.onload = function (evt) {
                console.log("generating content to file");
                gencache = generateHeader(ident, fileInfo.current, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, evt.target.result);
                setGeneratedFileUrl();
            }
        } else if (gencache) {
            console.log("writing content to file");
            setGeneratedFileUrl();
        }
    }
    const drawFonString = (cvsctx, fon, str, x, y, col) => {
        let xo = 0;
        let yo = 0;
        for (let i = 0; i < str.length; ++i) {
            if (str.charCodeAt(i) === '\r'.charCodeAt(0)) {
                xo = 0;
            } else if (str.charCodeAt(i) === '\n'.charCodeAt(0)) {
                yo += fon.lineHeight;
                xo = 0;
            } else {
                const ch = str.charCodeAt(i);
                const glyph = fonMakeGlyph(fon, ch, col);
                if (glyph && glyph.width) {
                    const data = new Uint8ClampedArray(glyph.data);
                    const image = new ImageData(data, glyph.width, glyph.height);
                    cvsctx.putImageData(image, xo + x, yo + y);
                    xo += glyph.width;
                } else {
                    xo += fon.width;
                }
            }

        }
    }
    const toUtf32 = function* (str) {
        for (const character of str) {
            let cp = character.codePointAt(0);
            if (cp >= 0xD800 && cp <= 0xDBFF) { // hi surrogate
                const cpl = character.codePointAt(1);
                if (!(cpl >= 0xDC00 && cpl <= 0xDFFF)) { // not a low surrogate
                    throw new Error("Unicode stream error. Unterminated high surrogate");
                }
                const highValue = cp & 1023;
                const lowValue = cpl & 1023;
                const magicAdd = 65536;
                cp = (highValue << 10) | lowValue + magicAdd;
            }
            yield cp;
        }
    }
    const drawVlwString = (cvsctx, vlw, str, x, y, col) => {
        let xo = 0;
        let yo = 0;
        for (const cp of toUtf32(str)) {
            if (cp === '\r'.charCodeAt(0)) {
                xo = 0;
            } else if (cp === '\n'.charCodeAt(0)) {
                yo += vlw.lineHeight;
                xo = 0;
            } else {
                const glyph = vlwMakeGlyph(vlw, cp, col);
                if (glyph && glyph.width) {
                    const data = new Uint8ClampedArray(glyph.data);
                    const image = new ImageData(data, glyph.width, glyph.height);
                    cvsctx.putImageData(image, xo + x + glyph.offset.x, yo + y + glyph.offset.y);
                    xo += glyph.advWidth;
                } else {
                    xo += vlw.spaceWidth;
                }
            }
        }
    }
    const previewFile = () => {
        if ((!fileInfo.current) || (!fileCache.current)) {
            console.log("No gen info");
            return;
        }
        let fcache = fileCache.current;
        
        const finfo = fileInfo.current;
        if (!fsize) {
            fsize = fontSize;
        }
        if (!funits) {
            funits = fontUnits;
        }
        if (!iscale) {
            iscale = imageScale;
        }
        if (!fset) {
            fset = fontSet;
        }
        if(!gentype) {
            if(!genType) {
                gentype="C";
            } else {
                gentype = genType;
            }
        }
        if (isSupportedImage(finfo)) {
            if (isFileExt(finfo.file.name,".tvg")) {
                tvgRender("tinyvg", fcache);
                const pic = document.getElementById("tinyvg");
                readImageDimensions(fcache, false).then((value) => {
                    imageDimensions = value;
                    setImageDim(imageDimensions);
                    let w = imageDimensions.width;
                    let h = imageDimensions.height;
                    pic.style = `width: ${w}px; height: ${h}px`;
                });
            } else if (isFileExt(finfo.file.name,".svg")) {
                const pic = document.getElementById("svgContainer");
                if (!pic) {
                    console.log("Could not find svg container");
                } else {
                    const decoder = new TextDecoder();
                    const str = decoder.decode(fcache);
                    pic.innerHTML = str;
                    readImageDimensions(fcache, true).then((value) => {
                        imageDimensions = value;
                        setImageDim(imageDimensions);
                        let w = imageDimensions.width;
                        let h = imageDimensions.height;
                        pic.style = `width: ${w}px; height: ${h}px`;
                    });
                }
            } else {
                const pic = document.getElementById("picture");
                if (!pic) {
                    console.log("Could not find picture");
                } else {
                    const blb = new Blob([fcache]);
                    const url = URL.createObjectURL(blb);
                    pic.src = url;
                    readImageDimensions(fcache, isFileExt(finfo.file.name,".svg")).then((value) => {
                        imageDimensions = value;
                        setImageDim(imageDimensions);
                        let w = imageDimensions.width;
                        let h = imageDimensions.height;
                        if (isFileExt(finfo.file.name,".jpg") && iscale) {
                            if(gentype && gentype.startsWith("G")) {
                                const dim = jpgScaleDim({width: w, height: h},iscale);
                                w=dim.width;
                                h=dim.height;
                            }
                        }
                        pic.width = w;
                        pic.height = h;
                    });

                }
            }
        } else if (isFileExt(finfo.file.name,".fon"))  {
            const fon = fonLoad(fcache, fset);
            fontLineHeight = fon.lineHeight;
            setFontHeight(fontLineHeight);
            const cvs = document.getElementById("rasterFont");
            if (!cvs) {
                console.log("Couldn't find font canvas");
            } else {
                cvs.width = cvs.offsetWidth;
                cvs.height = cvs.offsetHeight;

                const ctx = cvs.getContext("2d");
                ctx.clearRect(0, 0, cvs.width, cvs.height);

                drawFonString(ctx, fon,
                    "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz", 0, 0, 0xFF0FF0FF);
            }
        } else if(isFileExt(finfo.file.name,".vlw")) {
            const vlw = vlwLoad(fcache);
            fontLineHeight = vlw.lineHeight;
            setFontHeight(fontLineHeight);
            const cvs = document.getElementById("rasterFont");
            if (!cvs) {
                console.log("Couldn't find font canvas");
            } else {
                cvs.width = cvs.offsetWidth;
                cvs.height = cvs.offsetHeight;
                const ctx = cvs.getContext("2d");
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                drawVlwString(ctx, vlw,
                    "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz", 0, 0, 0xFF0FF0FF);
            }
        } else if (isTrueType(finfo.file.name)) {
            const spn = document.getElementById("vectorFont");
            if (!spn) {
                console.log("Couldn't find font container");
            } else {
                const blb = new Blob([fcache]);
                if (!idnt) {
                    idnt = ident;
                }
                if (!idnt) {
                    idnt = toIdentifier(finfo.file.name);
                }
                const fnturl = URL.createObjectURL(blb);
                const fnt = new FontFace(idnt, `url(${fnturl})`);
                fnt.load().then(() => {
                    document.fonts.add(fnt);
                    URL.revokeObjectURL(fnturl);
                    let fntsize = fsize;
                    let funit = funits;
                    if (!fntsize || fntsize === 0) {
                        fntsize = 2;
                    }
                    if (!funit) {
                        funit = "em";
                    }
                    spn.innerHTML = `<pre style="font: ${fntsize}${funit} ${idnt}; color: #FF0FF0;">` +
                        "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz".replace(/[\u00A0-\u9999<>\&]/g, i => '&#' + i.charCodeAt(0) + ';') +
                        "</pre>";
                });
            }
        }
    }
    const onDropFiles = (e) => {
        e.preventDefault();
        fileCache.current=undefined;
        const inputFile = document.getElementById("file");
        inputFile.files = e.dataTransfer.files;
        const fi = { file: e.dataTransfer.files[0], type: e.dataTransfer.files[0].type };
        fileInfo.current=fi;
        setIdent(toIdentifier(e.dataTransfer.files[0].name));

        setImageScale(undefined); // set this back so it doesn't accidentally get set to something other than the default
        setFontSize(undefined);
        setFontUnits(undefined);
        setFontSet(undefined);
        if (isSupportedImage(fi) ||
            isSupportedFont(fi)
        ) {
            let reader = new FileReader();
            reader.onload = async function (evt) {
                fileCache.current = evt.target.result;
                previewFile();
            };
            reader.readAsArrayBuffer(inputFile.files[0]);
        }
        gencache = undefined;
    }
    return (
        <>
            <div id="drop-target" onDrop={onDropFiles} className={"border-drag"} onDragOver={(event) => event.preventDefault()}>
                <p>Select or drag a file here</p>
                <div className="input-group">
                    <table border="0">
                        <tbody>
                            <tr>
                                <td colSpan={2}><input id="file" type="file" onChange={handleFileChange} /></td>
                            </tr>
                            <tr>
                                <td><label>Output:</label></td>
                                <td>
                                    <select id="output" defaultValue={genType} onChange={handleTypeChange}>
                                        <option value="C">Raw C/++</option>
                                        <option value="GFX2">GFX 2.x</option>
                                    </select>
                                </td>
                            </tr>
                            <tr>
                                <td><label>Identifier: </label></td><td><input type="text" id="identifier" value={ident} onChange={handleIdentChange} /></td>
                            </tr>
                            {fileInfo.current && isFileExt(fileInfo.current.file.name,".fon") && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Set Index: </label></td>
                                    <td>
                                        <input type="text" onChange={handleFontSetValueChange} />
                                    </td>
                                </tr>
                            )}
                            {fileInfo.current && isTrueType(fileInfo.current.file.name) && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Size: </label></td>
                                    <td>
                                        <input type="text" onChange={handleFontSizeValueChange} />
                                        <select onChange={handleFontSizeUnitChange}>
                                            <option>none</option>
                                            <option value="em">em</option>
                                            <option value="px">px</option>
                                        </select>
                                    </td>
                                </tr>
                            )}
                            {fileInfo.current && fileInfo.current.file.type == "image/jpeg" && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Scale: </label></td>
                                    <td>
                                        <select onChange={handleImageScaleChange}>
                                            <option value="scale_1_1">1:1</option>
                                            <option value="scale_1_2">1:2</option>
                                            <option value="scale_1_4">1:4</option>
                                            <option value="scale_1_8">1:8</option>
                                        </select>
                                    </td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
                {fileInfo.current && (
                    <section>
                        File details:
                        <ul>
                            {fileInfo.current.file.type && (
                                <li>MIME: <span className="fileType">{fileInfo.current.file.type}</span></li>)}
                            {isSupportedImage(fileInfo.current) && imageDim && (
                                <li>Dimensions: <span className="fileDim">{imageDim.width}x{imageDim.height}</span></li>)}
                            {isSupportedFont(fileInfo.current) && !isTrueType(fileInfo.current.file.name) && fontHeight && (
                                <li>Line Height: <span className="fontHeight">{fontHeight}</span></li>
                            )}
                            <li>Size: <span className="fileSize">{fileInfo.current.file.size} bytes</span></li>
                            <li>Type: <span className="genType">{getCreatedTypeName()}</span></li>
                        </ul>

                    </section>
                )}

                {fileInfo.current && ident && ident.length > 0 && (
                    <>
                        <button onClick={generateContentFile}
                            className="submit"
                        >Download header file</button><br />
                        <button
                            onClick={generateContentClip}
                            className="submit"
                        >Copy to clipboard</button>
                    </>
                )}
            </div><br />
            {fileInfo.current && (<><h4>Preview</h4></>)}
            {fileInfo.current && ident && ident.length > 0 && (<SyntaxHighlighter style={syntaxTheme} language={getGeneratedLanguage(genType)} >{generateHeader(ident, fileInfo.current, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, undefined)}</SyntaxHighlighter>)}
            {fileInfo.current && isFileExt(fileInfo.current.file.name,".tvg") && (<svg id="tinyvg" xmlns="http://www.w3.org/2000/svg"></svg>)}
            {fileInfo.current && !isFileExt(fileInfo.current.file.name,".tvg") && !isFileExt(fileInfo.current.file.name,".svg") && isSupportedImage(fileInfo.current) && (<img id="picture" onLoad={revokePicture()} />)}
            {fileInfo.current && isFileExt(fileInfo.current.file.name,".svg") && isSupportedImage(fileInfo.current) && (<div id="svgContainer" />)}
            {fileInfo.current && (isFileExt(fileInfo.current.file.name,".fon") || isFileExt(fileInfo.current.file.name,".vlw")) && (<canvas id="rasterFont" width={800} height={300} style={{ width: "%100", height: "100%" }} />)}
            {fileInfo.current && isTrueType(fileInfo.current.file.name) && (<span id="vectorFont" style={{ width: "800px", height: "300px" }} />)}
        </>
    );
};

export default HeaderGenerator;
