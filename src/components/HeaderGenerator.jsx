import React, { useState } from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { a11yDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import { generateStringLiteral, generateByteArrayLiteral, toIdentifier } from './CGen';
import { tvgDimensions, tvgRender } from './TinyVG';
import { fonLoad, fonMakeGlyph } from './FonFont';
import { vlwLoad, vlwMakeGlyph } from './VlwFont';
import './HeaderGenerator.css';

const isText = (type) => {
    return (type.endsWith("/json") || type.endsWith("/xml") || type.endsWith("+xml") || type.startsWith("text/"));
}
const isSupportedImage = (fileinfo) => {
    const fileName = fileinfo.file.name.toLowerCase();
    const fileType = fileinfo.file.type;
    if (fileType == "image/jpg" || fileType == "image/png" || fileType == "image/svg+xml") {
        return true;
    }
    if (fileName.endsWith(".jpg") || fileName.endsWith(".png") || fileName.endsWith(".svg") || fileName.endsWith(".tvg")) {
        return true;
    }
}
const jpgScaleDim = (dim, scale) => {
    let factor = 1;
    switch (scale) {
        case "scale_1_2":
            factor = .5; break;
        case "scale_1_4":
            factor = .25; break;
        case "scale_1_8":
            factor = .125; break;
        default: // case "scale_1_1": 
            return dim;
    }
    return { width: Math.ceil(dim.width * factor), height: Math.ceil(dim.height * factor) };
}

const isTrueType = (name) => {
    const n = name.toLowerCase();
    return n.endsWith(".ttf") || n.endsWith(".otf");
}

const generateHeader = (identifier, fileInfo, imageDim, imageScale, fontSetIndex, size, units, outputType, data) => {
    let result = "";
    if (imageScale === undefined || imageScale === "") {
        imageScale = "scale_1_1";
    }
    const fileName = fileInfo.file.name;
    const fileType = fileInfo.file.type;
    const isGfx = (outputType != undefined && outputType.length > 0 && outputType != "C");
    const guard = identifier.toUpperCase() + ((isGfx) ? "_HPP" : "_H");
    const impl = identifier.toUpperCase() + "_IMPLEMENTATION";
    result += "// Automatically generated by https://honeythecodewitch.com/gfx/header\r\n";
    result += `// #define ${impl} in exactly one\r\n`;
    let tukind = ".c/.cpp";
    if (isGfx) {
        tukind = ".cpp";
    }
    result += `// translation unit (${tukind} file) before including this header\r\n`;
    result += `#ifndef ${guard}\r\n`;
    result += `#define ${guard}\r\n`;
    const istext = isText(fileType);
    if (isGfx || !istext) {
        result += "#include <stdint.h>\r\n";
    }

    var imgSize;
    if (imageDim && imageDim.width && imageDim.height && imageDim.width > 0 && imageDim.height > 0) {
        imgSize = imageDim;
    }
    let isSpecialized = false;
    let isFon = false;
    let isTtf = false;
    let isVlw = false;
    let isJpg = false;
    let isPng = false;
    let isSvg = false;
    let isTvg = false;
    if (fileType === undefined || fileType === "" && fileName.toLowerCase().endsWith(".fon")) {
        isFon = true;
        isSpecialized = isFon;
    } else if (fileType === "image/jpeg") {
        isJpg = true;
        isSpecialized = true;
    } else if (fileType === "image/svg+xml") {
        isSvg = true;
    } else if (fileName.toLowerCase().endsWith(".tvg")) {
        isTvg = true;
    } else if (fileType === "image/png") {
        isPng = true;
        isSpecialized = true;
    } else if (fileName.toLowerCase().endsWith(".vlw")) {
        isVlw = true;
        isSpecialized = true;
    } else if (isTrueType(fileName) && size && !isNaN(size) && size != 0 && units) {
        isTtf = true;
        isSpecialized = true;
    }
    if (isGfx) {
        if (isFon) {
            result += "#include \"gfx_win_font.hpp\"\r\n\r\n";
            result += `extern gfx::win_font ${identifier};\r\n`;
        } else if (isVlw) {
            result += "#include \"gfx_vlw_font.hpp\"\r\n\r\n";
            result += `extern gfx::vlw_font ${identifier};\r\n`;
        } else if (isJpg) {
            result += "#include \"gfx_jpg_image.hpp\"\r\n\r\n";
            if (imgSize) {
                const dim = jpgScaleDim(imgSize, imageScale);
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${dim.width}, ${dim.height}}\r\n\r\n`
            }
            result += `extern gfx::jpg_image ${identifier};\r\n`;
        } else if (isPng) {
            result += "#include \"gfx_png_image.hpp\"\r\n\r\n";
            if (imgSize) {
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += `extern gfx::png_image ${identifier};\r\n`;
        } else if (isTtf) {
            result += "#include \"gfx_ttf_font.hpp\"\r\n\r\n";
            result += `extern gfx::ttf_font ${identifier};\r\n`;
        } else {
            result += "#include \"gfx_core.hpp\"\r\n\r\n";
            if (isSvg || isTvg) {
                if (imgSize) {
                    result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
                }
            }
            result += `extern gfx::const_buffer_stream ${identifier};\r\n`;
        }
    } else {
        if (istext) {
            if (data) {
                const view = new DataView(data);
                result += `#define ${identifier.toUpperCase()}_LENGTH (${view.byteLength})\r\n`;
            } else {
                result += `#define ${identifier.toUpperCase()}_LENGTH (${fileInfo.file.size})\r\n`;
            }
            if ((isSvg || isTvg || isPng || isJpg) && imgSize) {
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
            result += `const char* ${identifier};\r\n`;
        } else {
            if ((isSvg || isTvg || isPng || isJpg) && imgSize) {
                result += `#define ${identifier.toUpperCase()}_DIMENSIONS {${imgSize.width}, ${imgSize.height}}\r\n\r\n`
            }
            result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
            result += `const uint8_t ${identifier}[];\r\n`;
        }
    }
    result += `#endif // ${guard}\r\n\r\n`;
    result += `#ifdef ${impl}\r\n`;
    if (isGfx) {
        if (istext) {
            result += generateStringLiteral(identifier + "_data", data, true) + "\r\n\r\n";
        } else {
            result += generateByteArrayLiteral(identifier + "_data", data, true) + "\r\n\r\n";
        }
        if (isSpecialized) {
            result += `static gfx::const_buffer_stream ${identifier}_stream\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
        }
        if (isFon) {
            if (fontSetIndex != 0) {
                result += `gfx::win_font ${identifier}\r\n    (${identifier}_stream, ${fontSetIndex});\r\n`;
            } else {
                result += `gfx::win_font ${identifier}\r\n    (${identifier}_stream);\r\n`;
            }
        } else if (isVlw) {
            result += `gfx::vlw_font ${identifier}\r\n    (${identifier}_stream);\r\n`;
        } else if (isJpg) {
            if (imageScale != "scale_1_1") {
                result += `gfx::jpg_image ${identifier}\r\n    (${identifier}_stream, jpg_scale::${imageScale});\r\n`;
            } else {
                result += `gfx::jpg_image ${identifier}\r\n    (${identifier}_stream);\r\n`;
            }
        } else if (isPng) {
            result += `gfx::png_image ${identifier}\r\n    (${identifier}_stream);\r\n`;
        } else if (isTtf) {
            result += `gfx::ttf_font ${identifier}\r\n    (${identifier}_stream, ${size}, gfx::font_size_units::${units})\r\n`;
        } else {
            if (istext) {
                if (data) {
                    const view = new DataView(data);
                    result += `gfx::const_buffer_stream ${identifier}\r\n    ((const uint8_t*)${identifier}_data, ${view.byteLength});\r\n`;
                } else {
                    result += `gfx::const_buffer_stream ${identifier}\r\n    ((const uint8_t*)${identifier}_data, ${fileInfo.file.size});\r\n`;
                }
            } else {
                result += `gfx::const_buffer_stream ${identifier}\r\n    (${identifier}_data, sizeof(${identifier}_data));\r\n`;
            }
        }
    } else {
        if (istext) {
            result += generateStringLiteral(identifier, data, false) + "\r\n";
        } else {
            result += generateByteArrayLiteral(identifier, data, false) + "\r\n";
        }
    }
    result += `#endif // ${impl}\r\n`;
    return result;
}
const getDownloadName = (ident, genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return `${ident}.h`;
    }
    return `${ident}.hpp`;
}
const getGeneratedLanguage = (genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return "c";
    }
    return "cpp";
}
const HeaderGenerator = () => {
    let downloadUrl = "";
    var gencache;
    var imageDimensions;
    var fontLineHeight;
    var filecache;
    var idnt;
    var finfo;
    var fsize;
    var fset;
    var funits;
    var iscale;
    const [fileInfo, setFileInfo] = useState("");
    const [ident, setIdent] = useState("");
    const [fontSet, setFontSet] = useState(0);
    const [fontHeight, setFontHeight] = useState(0);
    const [fontSize, setFontSize] = useState(0);
    const [fontUnits, setFontUnits] = useState("em");
    const [imageScale, setImageScale] = useState("scale_1_1");
    const [imageDim, setImageDim] = useState("");
    const [genType, setGenType] = useState("C");
    const [genContent, setGenContent] = useState(undefined)
    const [fileCache, setFileCache] = useState(undefined)
    const handleFileChange = (e) => {
        setFileInfo({ file: e.target.files[0], type: e.target.files[0].type });
        setIdent(toIdentifier(e.target.files[0].name));
        gencache = undefined;
    };
    const handleIdentChange = (e) => {
        if (ident != e.target.value) {
            idnt = e.target.value;
            setIdent(idnt);
            gencache = undefined;
            setGenContent(undefined);
        }
    }
    const handleFontSetValueChange = (e) => {
        let n = Number.parseInt(e.target.value);
        if (isNaN(n)) {
            n = 0;
        }
        fset = n;
        setFontSet(fset);
        gencache = undefined;
        setGenContent(undefined);
        previewFile();

    }
    const handleImageScaleChange = (e) => {
        let s = e.target.value;
        if (s === undefined || s === "") {
            s = "scale_1_1";
        }
        iscale = s;
        setImageScale(s);
        gencache = undefined;
        setGenContent(undefined);
        previewFile();
    }
    const handleFontSizeValueChange = (e) => {
        let n = Number.parseFloat(e.target.value);
        if (isNaN(n)) {
            n = 0;
        }
        fsize = n;
        setFontSize(n);
        gencache = undefined;
        setGenContent(undefined);
        previewFile();

    }
    const handleFontSizeUnitChange = (e) => {
        let u = e.target.value;
        if (u === "none" || u === undefined || u === "") {
            setFontSize(0);
            setFontUnits(u);
            gencache = undefined;
            setGenContent(undefined);
            previewFile();
            return;
        }
        if (u != "em" && u != "px") {
            u = "em";
        }
        funits = u;
        fsize = 0;
        setFontUnits(u);
        gencache = undefined;
        setGenContent(undefined);
        previewFile();

    }
    const handleTypeChange = (e) => {
        if (genType != e.target.value) {
            setGenType(e.target.value);
            gencache = undefined;
            setGenContent(undefined);
        }
    }

    const readImageDimensions = async (data, isSvg = false) => {
        return new Promise((resolve, reject) => {
            if (!isSvg) {
                let dim = tvgDimensions(data);
                if (dim) {
                    resolve(dim);
                }
                else {
                    const imgsrc = URL.createObjectURL(new Blob([data]));
                    const img = new Image();
                    img.onload = () => {
                        dim = {
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        };
                        resolve(dim);
                    };
                    img.src = imgsrc;
                }
            } else {
                var decoder = new TextDecoder('utf-8');
                const svgstr = decoder.decode(data);
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgstr, 'image/svg+xml');
                const svg = doc.documentElement;

                // Get bounding box of all content
                document.body.appendChild(svg);
                const bbox = svg.getBBox();
                document.body.removeChild(svg);
                const dim = {
                    width: Math.ceil(bbox.width + bbox.x),
                    height: Math.ceil(bbox.height + bbox.y)
                };
                if (dim && dim.width > 0) {
                    resolve(dim);
                } else {
                    reject();
                }
            }
            

        });
    }
    const getCreatedTypeName = () => {
        if (fileInfo) {
            if (!genType || genType === "" || genType === "C") {
                if (isText(fileInfo.type)) {
                    return "const char*";
                } else {
                    return "const uint8_t[]";
                }
            }
            const fileType = fileInfo.type;
            const fileName = fileInfo.file.name;
            const size = fontSize;
            const units = fontUnits;
            if (fileType === undefined || fileType === "" && fileName.toLowerCase().endsWith(".fon")) {
                return "gfx::win_font";
            } else if (fileType === "image/jpeg") {
                return "gfx::jpg_image";
            } else if (fileType === "image/png") {
                return "gfx::png_image";
            } else if (fileName.toLowerCase().endsWith(".vlw")) {
                return "gfx::vlw_font";
            } else if (isTrueType(fileName) && size && !isNaN(size) && size != 0 && units) {
                return "gfx::ttf_font";
            }

            return "gfx::const_buffer_stream";

        }
        return undefined;
    }

    const generateContentClip = () => {
        if (!gencache && fileInfo.file) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(fileInfo.file);
            reader.onload = async function (evt) {
                console.log("generating content to clipboard");
                gencache = generateHeader(ident, fileInfo, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, evt.target.result);
                await navigator.clipboard.writeText(gencache);
            }
        } else if (gencache) {
            console.log("writing content to clipboard");
            navigator.clipboard.writeText(gencache);
        }
    }
    const setGeneratedFileUrl = () => {
        // this is a hack. alink must be created outside React's normal rendering sequence
        // due to the on the fly generate+download in one click feature. It's a bit kludgy but
        // it works
        const blb = new Blob([gencache], { type: "text/plain" });
        if (downloadUrl != undefined && downloadUrl.length > 0) {
            URL.revokeObjectURL(downloadUrl);
        }
        downloadUrl = URL.createObjectURL(blb);

        const alink = document.createElement("a");
        alink.download = getDownloadName(ident, genType);
        alink.href = downloadUrl;
        alink.click();
    }
    const revokePicture = () => {
        setTimeout(function () { URL.revokeObjectURL(document.getElementById("picture").src); }, 10000);
    }

    const generateContentFile = () => {
        if (!gencache && fileInfo.file) {
            let reader = new FileReader();
            reader.readAsArrayBuffer(fileInfo.file);
            reader.onload = function (evt) {
                console.log("generating content to file");
                gencache = generateHeader(ident, fileInfo, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, evt.target.result);
                setGeneratedFileUrl();
            }
        } else if (gencache) {
            console.log("writing content to file");
            setGeneratedFileUrl();
        }
    }
    const drawFonString = (cvsctx, fon, str, x, y, col) => {
        let xo = 0;
        let yo = 0;
        for (let i = 0; i < str.length; ++i) {
            if (str.charCodeAt(i) === '\r'.charCodeAt(0)) {
                xo = 0;
            } else if (str.charCodeAt(i) === '\n'.charCodeAt(0)) {
                yo += fon.lineHeight;
                xo = 0;
            } else {
                const ch = str.charCodeAt(i);
                const glyph = fonMakeGlyph(fon, ch, col);
                if (glyph && glyph.width) {
                    const data = new Uint8ClampedArray(glyph.data);
                    const image = new ImageData(data, glyph.width, glyph.height);
                    cvsctx.putImageData(image, xo + x, yo + y);
                    xo += glyph.width;
                } else {
                    xo += fon.width;
                }
            }

        }
    }
    const toUtf32 = function* (str) {
        for (const character of str) {
            let cp = character.codePointAt(0);
            if (cp >= 0xD800 && cp <= 0xDBFF) { // hi surrogate
                const cpl = character.codePointAt(1);
                if (!(cpl >= 0xDC00 && cpl <= 0xDFFF)) { // not a low surrogate
                    throw new Error("Unicode stream error. Unterminated high surrogate");
                }
                const highValue = cp & 1023;
                const lowValue = cpl & 1023;
                const magicAdd = 65536;
                cp = (highValue << 10) | lowValue + magicAdd;
            }
            yield cp;
        }
    }
    const drawVlwString = (cvsctx, vlw, str, x, y, col) => {
        let xo = 0;
        let yo = 0;
        for (const cp of toUtf32(str)) {
            if (cp === '\r'.charCodeAt(0)) {
                xo = 0;
            } else if (cp === '\n'.charCodeAt(0)) {
                yo += vlw.lineHeight;
                xo = 0;
            } else {
                const glyph = vlwMakeGlyph(vlw, cp, col);
                if (glyph && glyph.width) {
                    const data = new Uint8ClampedArray(glyph.data);
                    const image = new ImageData(data, glyph.width, glyph.height);
                    cvsctx.putImageData(image, xo + x + glyph.offset.x, yo + y + glyph.offset.y);
                    xo += glyph.advWidth;
                } else {
                    xo += vlw.spaceWidth;
                }

            }
        }
    }
    const previewFile = () => {
        if ((!finfo && !fileInfo) || (!filecache && !fileCache)) {
            console.log("No gen info");
            return;
        }
        if (!filecache) {
            filecache = fileCache;
        }
        if (!finfo) {
            finfo = fileInfo;
        }
        if (!fsize) {
            fsize = fontSize;
        }
        if (!funits) {
            funits = fontUnits;
        }
        if (!iscale) {
            iscale = imageScale;
        }
        if (!fset) {
            fset = fontSet;
        }

        if (isSupportedImage(finfo)) {
            if (finfo.file.name.toLowerCase().endsWith(".tvg")) {
                tvgRender("tinyvg", filecache);
                const pic = document.getElementById("tinyvg");
                readImageDimensions(filecache, false).then((value) => {
                    imageDimensions = value;
                    setImageDim(imageDimensions);
                    let w = imageDimensions.width;
                    let h = imageDimensions.height;
                    pic.style=`width: ${w}px; height: ${h}px`;
                    });
            } else if (finfo.file.name.toLowerCase().endsWith(".svg")) {
                const pic = document.getElementById("svgContainer");
                if (!pic) {
                    console.log("Could not find svg container");
                } else {
                    const decoder = new TextDecoder();
                    const str = decoder.decode(filecache);
                    pic.innerHTML = str;
                    readImageDimensions(filecache, true).then((value) => {
                        imageDimensions = value;
                        setImageDim(imageDimensions);
                        let w = imageDimensions.width;
                        let h = imageDimensions.height;
                        pic.style=`width: ${w}px; height: ${h}px`;
                    });
                }
            } else {
                const pic = document.getElementById("picture");
                if (!pic) {
                    console.log("Could not find picture");
                } else {
                    const blb = new Blob([filecache]);
                    const url = URL.createObjectURL(blb);
                    pic.src = url;
                    console.log(imageDimensions);
                    readImageDimensions(filecache, finfo.file.name.toLowerCase().endsWith(".svg")).then((value) => {
                        imageDimensions = value;
                        setImageDim(imageDimensions);
                        let w = imageDimensions.width;
                        let h = imageDimensions.height;
                        if(finfo.file.name.toLowerCase().endsWith(".jpg") && iscale) {
                            switch(iscale) {
                                case "scale_1_2":
                                    w/=2;
                                    h/=2;
                                    break;
                                case "scale_1_4":
                                    w/=4;
                                    h/=4;
                                    break;
                                case "scale_1_8":
                                    w/=8;
                                    h/=8;
                                    break;

                            }
                        }
                        pic.width=w;
                        pic.height=h;
                    });
                    
                }
            }
        } else if (finfo.file.name.toLowerCase().endsWith(".fon") || finfo.file.name.toLowerCase().endsWith(".vlw")) {
            if (finfo.file.name.toLowerCase().endsWith(".fon")) {
                const fon = fonLoad(filecache, fset);
                fontLineHeight = fon.lineHeight;
                setFontHeight(fontLineHeight);
                const cvs = document.getElementById("rasterFont");
                if (!cvs) {
                    console.log("Couldn't find font canvas");
                } else {
                    cvs.width = cvs.offsetWidth;
                    cvs.height = cvs.offsetHeight;

                    const ctx = cvs.getContext("2d");
                    ctx.clearRect(0, 0, cvs.width, cvs.height);

                    drawFonString(ctx, fon,
                        "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz", 0, 0, 0xFF0FF0FF);
                }
            } else {
                const vlw = vlwLoad(filecache);
                fontLineHeight = vlw.lineHeight;
                setFontHeight(fontLineHeight);
                const cvs = document.getElementById("rasterFont");
                if (!cvs) {
                    console.log("Couldn't find font canvas");
                } else {
                    cvs.width = cvs.offsetWidth;
                    cvs.height = cvs.offsetHeight;
                    const ctx = cvs.getContext("2d");
                    ctx.clearRect(0, 0, cvs.width, cvs.height);
                    drawVlwString(ctx, vlw,
                        "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz", 0, 0, 0xFF0FF0FF);
                }
            }
        } else if (isTrueType(finfo.file.name)) {
            const spn = document.getElementById("vectorFont");
            if (!spn) {
                console.log("Couldn't find font container");
            } else {
                const blb = new Blob([filecache]);
                if (!idnt) {
                    idnt = ident;
                }
                if (!idnt) {
                    idnt = toIdentifier(finfo.file.name);
                }
                const fnturl = URL.createObjectURL(blb);
                const fnt = new FontFace(idnt, `url(${fnturl})`);
                fnt.load().then(() => {
                    document.fonts.add(fnt);
                    URL.revokeObjectURL(fnturl);
                    let fntsize = fsize;
                    let funit = funits;
                    if (!fntsize || fntsize === 0) {
                        fntsize = 2;
                    }
                    if (!funit) {
                        funit = "em";
                    }
                    spn.innerHTML = `<pre style="font: ${fntsize}${funit} ${idnt}; color: #FF0FF0;">` +
                        "0123456789/\\.,_-+()[]{}$%?\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz".replace(/[\u00A0-\u9999<>\&]/g, i => '&#' + i.charCodeAt(0) + ';') +
                        "</pre>";
                });
            }
        }
    }
    const onDropFiles = (e) => {
        e.preventDefault();
        filecache = undefined;
        const inputFile = document.getElementById("file");
        inputFile.files = e.dataTransfer.files;
        const fi = { file: e.dataTransfer.files[0], type: e.dataTransfer.files[0].type };
        finfo = fi;
        setFileInfo(fi);
        setIdent(toIdentifier(e.dataTransfer.files[0].name));

        setImageScale(undefined); // set this back so it doesn't accidentally get set to something other than the default
        setFontSize(undefined);
        setFontUnits(undefined);
        setFontSet(undefined);
        setGenContent(undefined);
        if (isSupportedImage(fi) ||
            (fi.file.name.toLowerCase().endsWith(".vlw") || fi.file.name.toLowerCase().endsWith(".fon")) ||
            isTrueType(fi.file.name)
        ) {
            let reader = new FileReader();
            reader.onload = async function (evt) {
                filecache = evt.target.result;
                setFileCache(filecache);
                finfo = fi;
                setGenContent(filecache);
                previewFile();
            };
            reader.readAsArrayBuffer(inputFile.files[0]);
        }
        gencache = undefined;
    }
    return (
        <>
            <div id="drop-target" onDrop={onDropFiles} className={"border-drag"} onDragOver={(event) => event.preventDefault()}>
                <p>Select or drag a file here</p>
                <div className="input-group">
                    <table border="0">
                        <tbody>
                            <tr>
                                <td colSpan={2}><input id="file" type="file" onChange={handleFileChange} /></td>
                            </tr>
                            <tr>
                                <td><label>Output:</label></td>
                                <td>
                                    <select id="output" value={genType} onChange={handleTypeChange}>
                                        <option value="C">Raw C/++</option>
                                        <option value="GFX2">GFX 2.x</option>
                                    </select>
                                </td>
                            </tr>
                            <tr>
                                <td><label>Identifier: </label></td><td><input type="text" id="identifier" value={ident} onChange={handleIdentChange} /></td>
                            </tr>
                            {fileInfo && fileInfo.file.name.toLowerCase().endsWith(".fon") && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Set Index: </label></td>
                                    <td>
                                        <input type="text" value={fontSet} onChange={handleFontSetValueChange} />
                                    </td>
                                </tr>
                            )}
                            {fileInfo && isTrueType(fileInfo.file.name) && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Size: </label></td>
                                    <td>
                                        <input type="text" onChange={handleFontSizeValueChange} />
                                        <select onChange={handleFontSizeUnitChange}>
                                            <option>none</option>
                                            <option value="em">em</option>
                                            <option value="px">px</option>
                                        </select>
                                    </td>
                                </tr>
                            )}
                            {fileInfo && fileInfo.file.type == "image/jpeg" && genType.startsWith("G") && (
                                <tr>
                                    <td><label>Scale: </label></td>
                                    <td>
                                        <select onChange={handleImageScaleChange}>
                                            <option value="scale_1_1">1:1</option>
                                            <option value="scale_1_2">1:2</option>
                                            <option value="scale_1_4">1:4</option>
                                            <option value="scale_1_8">1:8</option>
                                        </select>
                                    </td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
                {fileInfo && (
                    <section>
                        File details:
                        <ul>
                            {fileInfo.file.type && (
                                <li>MIME: <span className="fileType">{fileInfo.file.type}</span></li>)}
                            {isSupportedImage(fileInfo) && imageDim && (
                                <li>Dimensions: <span className="fileDim">{imageDim.width}x{imageDim.height}</span></li>)}
                            <li>Size: <span className="fileSize">{fileInfo.file.size} bytes</span></li>
                            <li>Type: <span className="genType">{getCreatedTypeName()}</span></li>
                        </ul>

                    </section>
                )}

                {fileInfo && ident && ident.length > 0 && (
                    <>
                        <button onClick={generateContentFile}
                            className="submit"
                        >Download header file</button><br />
                        <button
                            onClick={generateContentClip}
                            className="submit"
                        >Copy to clipboard</button>
                    </>
                )}
            </div><br />
            {fileInfo && (<><h4>Preview</h4></>)}
            {fileInfo && ident && ident.length > 0 && (<SyntaxHighlighter style={a11yDark} language={getGeneratedLanguage(genType)} >{generateHeader(ident, fileInfo, imageDim, imageScale, fontSet, fontSize, fontUnits, genType, undefined)}</SyntaxHighlighter>)}
            {fileInfo && fileInfo.file.name.toLowerCase().endsWith(".tvg") && (<svg id="tinyvg" xmlns="http://www.w3.org/2000/svg"></svg>)}
            {fileInfo && !fileInfo.file.name.toLowerCase().endsWith(".tvg") && !fileInfo.file.name.toLowerCase().endsWith(".svg") && isSupportedImage(fileInfo) && (<img id="picture" onLoad={revokePicture()} />)}
            {fileInfo && fileInfo.file.name.toLowerCase().endsWith(".svg") && isSupportedImage(fileInfo) && (<div id="svgContainer" />)}
            {fileInfo && (fileInfo.file.name.toLowerCase().endsWith(".fon") || fileInfo.file.name.toLowerCase().endsWith(".vlw")) && (<canvas id="rasterFont" width={800} height={300} style={{ width: "%100", height: "100%" }} />)}
            {fileInfo && isTrueType(fileInfo.file.name) && (<span id="vectorFont" style={{ width: "800px", height: "300px" }} />)}
        </>
    );
};

export default HeaderGenerator;
