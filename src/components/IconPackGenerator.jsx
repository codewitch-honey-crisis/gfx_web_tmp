import React, { useMemo, useState, useRef, useEffect, Suspense } from 'react';
import { Light as SyntaxHighlighter } from 'react-syntax-highlighter';
import clang from 'react-syntax-highlighter/dist/esm/languages/hljs/c';
import cpplang from 'react-syntax-highlighter/dist/esm/languages/hljs/cpp';
import { a11yDark, a11yLight } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import { generateByteArrayLiteral, generateStringLiteral, toIdentifier } from './CGen';
import IconBox from './IconBox';
import './IconPackGenerator.css';
import { filteredIcons, selectedIcons, rasterizeSvg, scaleIcon, computeBitmapsTotalBytes } from './Icons';
const makeSafeName = (names, name) => {
    let j = 1;
    let cmp = name;
    while (names.has(cmp)) {
        cmp = `${name}${++j}`;
    }
    names.set(cmp, cmp);
    return cmp;
}
const generateHeaderAsync = async (icons, iconsSel, fileName, bitDepth, clampHeight, clampWidth, outputType, preview) => {
    const names = new Map();
    const isGfx = (outputType != undefined && outputType.length > 0 && outputType != "C");
    const ident = toIdentifier(fileName);
    const guard = ident.toUpperCase() + ((isGfx) ? "_HPP" : "_H");
    const impl = ident.toUpperCase() + "_IMPLEMENTATION";
    let result = "// Automatically generated by https://honeythecodewitch.com/gfx/icon-pack\r\n";
    result += `// #define ${impl} in exactly one\r\n`;
    let tukind = ".c/.cpp";
    if (isGfx) {
        tukind = ".cpp";
    }
    result += `// translation unit (${tukind} file) before including this header\r\n`;
    result += `#ifndef ${guard}\r\n`;
    result += `#define ${guard}\r\n`;
    result += "#include <stdint.h>\r\n";
    if (isGfx) {
        if(bitDepth>0) {
            result += "#include \"gfx_pixel.hpp\"\r\n#include \"gfx_bitmap.hpp\"\r\n";
        } else {
            result +="#include \"gfx_core.hpp\"\r\n#include \"gfx_positioning.hpp\"\r\n";
        }
    }
    result += "\r\n";
    if(bitDepth>0) {
        result += `#define ${ident.toUpperCase()}_BIT_DEPTH ${bitDepth}\r\n`
    }
    if (clampHeight && clampHeight > 0) {
        result += `#define ${ident.toUpperCase()}_HEIGHT ${clampHeight}\r\n`
    } else if (clampWidth && clampWidth > 0) {
        result += `#define ${ident.toUpperCase()}_WIDTH ${clampWidth}\r\n`
    } else {
        clampHeight = 32;
        result += `#define ${ident.toUpperCase()}_HEIGHT ${clampHeight}\r\n`
    }

    result += "\r\n";
    for (let i = 0; i < iconsSel.length; ++i) {
        const icon = icons[iconsSel[i]];
        const dim = scaleIcon(icon, clampWidth, clampHeight);
        const id = makeSafeName(names, toIdentifier(`${fileName}_${icon.name}`));
        if (!isGfx) {
            if(bitDepth==0) {
                result += `#define ${id.toUpperCase()}_DIMENSIONS {${icon.width}, ${icon.height}}\r\n`;
                result += `#define ${id.toUpperCase()}_SCALED_DIMENSIONS {${dim.width}, ${dim.height}}\r\n`;
                result += `#define ${id.toUpperCase()}_SCALE (${dim.scale})\r\n`;
            } else {
                result += `#define ${id.toUpperCase()}_DIMENSIONS {${dim.width}, ${dim.height}}\r\n`;
            }
            result += "#ifdef __cplusplus\r\nextern \"C\"\r\n#else\r\nextern\r\n#endif\r\n";
        }
        if(bitDepth>0) {
            result += `/// @brief "${icon.label}" - a ${dim.width}x${dim.height} alpha transparency map\r\n`;
            if (isGfx) {
                result += `const gfx::const_bitmap<gfx::alpha_pixel<${bitDepth}>> ${id};\r\n`;
            } else {
                result += `const uint8_t ${id}[];\r\n`;
            }
        } else {
            if(isGfx) {
                result+= `/// @brief "${icon.label}" dimensions\r\n`;
                result+= `constexpr static const gfx::sizef ${id}_dimensions(${icon.width},${icon.height});\r\n`;
                result+= `/// @brief "${icon.label}" scaled dimensions\r\n`;
                result+= `constexpr static const gfx::size16 ${id}_scaled_dimensions(${dim.width},${dim.height});\r\n`;
                result+= `/// @brief "${icon.label}" target scale\r\n`;
                result+= `constexpr static const float ${id}_scale = ${dim.scale};\r\n`;
            }
            result += `/// @brief "${icon.label}" - a SVG vector icon\r\n`;
            if (isGfx) {
                result += `extern gfx::const_buffer_stream ${id};\r\n`;
            } else {
                result += `const char* ${id};\r\n`;
            }
        }
    }
    result += `#endif // ${guard}\r\n\r\n`;
    result += `#ifdef ${impl}\r\n`;
    names.clear();
    for (let i = 0; i < iconsSel.length; ++i) {
        const icon = icons[iconsSel[i]];
        const dim = scaleIcon(icon, clampWidth, clampHeight);
        const id = makeSafeName(names, toIdentifier(`${fileName}_${icon.name}`));
        const data_id = isGfx ? `${id}_data` : id;
        if(bitDepth>0) {
            let data;
            if (!preview) {
                data = await rasterizeSvg(icon.svg, icon.width, icon.height, dim.width, dim.height, bitDepth);
            }
            const widthFactor = bitDepth / 8;
            let widthBytes = Math.ceil(dim.width * widthFactor);
            result += generateByteArrayLiteral(data_id, preview ? undefined : data.bitmap, isGfx, widthBytes);
            result += "\r\n";
            if (isGfx) {
                result += `const gfx::const_bitmap<gfx::alpha_pixel<${bitDepth}>> ${id}\r\n    ({${dim.width}, ${dim.height}}, ${data_id});\r\n`;
            }
            if (i < iconsSel.length - 1) {
                result += "\r\n";
            }
        } else {
            const enc = new TextEncoder("utf-8");
            const buf = enc.encode(icon.svg).buffer
            result += generateStringLiteral(data_id,preview?undefined:buf,isGfx);
            result += "\r\n";
            if (isGfx) {
                result += `gfx::const_buffer_stream ${id}\r\n    ((const uint8_t*)${data_id}, ${icon.svg.length});\r\n`;
            }
            if (i < iconsSel.length - 1) {
                result += "\r\n";
            }
        }
    }
    result += `#endif // ${impl}\r\n`;
    return result;
}
const generateHeader = (icons, iconsSel, fileName, bitDepth, clampHeight, clampWidth, outputType, preview) => {
    let result;
    let err;
    const promise = generateHeaderAsync(icons, iconsSel, fileName, bitDepth, clampHeight, clampWidth, outputType, preview)
        .then((response) => result = response, (error) => { err = error; })
    return {
        read() {
            if (err) {
                throw err;
            }
            if (!result) {
                throw promise;
            }
            return result;
        },
    };
};
const wrapPromise = (promise) => {
    let status = 'pending';
    let result;
    let data;
    const suspender = promise.then(
        (r) => {
            status = 'success';
            result = r;
        },
        (e) => {
            status = 'error';
            result = e;
        }
    );

    return {
        read() {
            if (status === 'pending') {
                throw suspender;
            } else if (status === 'error') {
                throw result;
            } else if (status === 'success') {
                return result;
            }
        },
    };
}

const fetchIcons = () => {
    console.log("fetching icons");
    const promise = fetch("../icons/icons.json")
        .then((res) => {
            if (!res.ok) {
                throw new Error(`HTTP error! Status: ${res.status}`);
            }
            return res.json();
        })
        .then((data) => data)
        .catch((error) => {
            console.error('Fetch error:', error);
            throw error;
        });

    return wrapPromise(promise);
}

const isBrowserDarkTheme = () => {
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return true;
    }
    return false;
}
const getDownloadName = (ident, genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return `${ident}.h`;
    }
    return `${ident}.hpp`;
}
const getGeneratedLanguage = (genType) => {
    if (genType === "C" || genType === undefined || genType === "") {
        return "c";
    }
    return "cpp";
}

const iconData = fetchIcons();
const IconPackGenerator = () => {
    SyntaxHighlighter.registerLanguage('c', clang);
    SyntaxHighlighter.registerLanguage('cpp', cpplang);
    const [syntaxTheme, setSyntaxTheme] = useState(isBrowserDarkTheme() ? a11yDark : a11yLight);
    const [genType, setGenType] = useState("C");
    const [moduleId, setModuleId] = useState("icons");
    const [clampAxis, setClampAxis] = useState("height");
    const [clampValue, setClampValue] = useState("32");
    const [bitDepth, setBitDepth] = useState("8");
    const [iconFilter, setIconFilter] = useState(undefined);
    const downloadUrl = useRef(undefined);
    let gencache;

    useEffect(() => {
        const handleThemeChange = (event) => {
            setSyntaxTheme(event.matches ? a11yDark : a11yLight);
        };
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addEventListener('change', handleThemeChange);
        return () => mediaQuery.removeEventListener('change', handleThemeChange); // clean up your event listerens
    }, []); // runs on mount
    const mapIcons = (icons) => {
        const keys = [];
        Object.keys(icons).forEach(function (key) {
            keys.push(key);
        })
        keys.sort();
        const mapdata = new Map();
        const result = [];
        var parser = new DOMParser();
        let di = 0;
        for (const k of keys) {
            if (k && k.length > 0) {
                const icon = icons[k];
                let search = "";
                if (icon.search && icon.search.terms) {
                    for (let i = 0; i < icon.search.terms.length; ++i) {
                        search += `${icon.search.terms[i]} `;
                    }
                }
                const entries = Object.entries(icon["svg"]);
                if (entries) {
                    for (const [key, value] of entries) {
                        if (value["raw"]) {
                            const svg = value["raw"];
                            let w = Math.ceil(value.width);
                            if (isNaN(w)) {
                                w = 512;
                            }
                            let h = Math.ceil(value.height);
                            if (isNaN(h)) {
                                h = 512;
                            }
                            let name = toIdentifier(k);

                            let safename = (key === "solid") ? name : `${name}_${key}`;
                            let j = 1;
                            while (mapdata.has(safename)) {
                                j++;
                                safename = name + j.toString(10);
                            }
                            name = safename;
                            const data = {
                                key: name,
                                index: di,
                                label: icon.label,
                                name: k,
                                width: w,
                                height: h,
                                svg: svg,
                                search: search
                            };
                            mapdata[name] = data;
                            result.push(data);
                            ++di;
                        }
                    };
                }
            }
        }
        return result;
    }


    const handleIconFilterChange = (evt) => {
        setIconFilter(evt.target.value);
    }
    const handleClampAxisChange = (evt) => {
        setClampAxis(evt.target.value);
    }
    const handleClampValueChange = (evt) => {
        setClampValue(evt.target.value);
    }
    const handleGenTypeChange = (evt) => {
        setGenType(evt.target.value);
    }
    const handleModuleChange = (evt) => {
        setModuleId(evt.target.value);
    }
    const handleBitDepthChange = (evt) => {
        setBitDepth(evt.target.value);
    }

    const icons = useMemo(() => mapIcons(iconData.read()));

    const [iconSel, setIconSel] = useState([]);
    const generateContentClip = () => {
        if (!gencache && clampValue && clampValue > 0 && moduleId && moduleId.length > 0) {
            console.log("generating content to clipboard");
            generateHeaderAsync(icons, iconSel, moduleId, parseInt(bitDepth), clampAxis !== "width" ? parseInt(clampValue) : undefined, clampAxis === "width" ? parseInt(clampValue) : undefined, genType, false).then((result) => {
                gencache = result;
                navigator.clipboard.writeText(gencache);
            });

        } else if (gencache) {
            console.log("writing content to clipboard");
            navigator.clipboard.writeText(gencache);
        }
    }
    const setGeneratedFileUrl = () => {
        // this is a hack. alink must be created outside React's normal rendering sequence
        // due to the on the fly generate+download in one click feature. It's a bit kludgy but
        // it works
        const blb = new Blob([gencache], { type: "text/plain" });
        if (downloadUrl.current != undefined && downloadUrl.current.length > 0) {
            URL.revokeObjectURL(downloadUrl.current);
            downloadUrl.current = "";
        }
        downloadUrl.current = URL.createObjectURL(blb);

        const alink = document.createElement("a");
        alink.download = getDownloadName(moduleId, genType);
        alink.href = downloadUrl.current;
        alink.click();
        setTimeout(() => { if (downloadUrl.current && downloadUrl.current.length > 0) { URL.revokeObjectURL(downloadUrl.current), downloadUrl.current = ""; } }, 500);
    }
    const generateContentFile = () => {
        if (!gencache && clampValue && clampValue > 0 && moduleId && moduleId.length > 0) {
            console.log("generating content to file");
            generateHeaderAsync(icons, iconSel, moduleId, parseInt(bitDepth), clampAxis !== "width" ? parseInt(clampValue) : undefined, clampAxis === "width" ? parseInt(clampValue) : undefined, genType, false).then((result) => {
                gencache = result;
                setGeneratedFileUrl();
            });
        } else if (gencache) {
            console.log("writing content to file");
            setGeneratedFileUrl();
        }
    }
    const genAsync = generateHeader(icons, iconSel, moduleId, parseInt(bitDepth), clampAxis !== "width" ? parseInt(clampValue) : undefined, clampAxis === "width" ? parseInt(clampValue) : undefined, genType, true);

    const handleIconSelectedChange = (node, evt) => {
        if (evt.target.checked) {
            const result = [];
            for (let i = 0; i < iconSel.length; ++i) {
                if (iconSel[i] !== node.index) {
                    result.push(iconSel[i])
                }
            }
            result.push(node.index);
            setIconSel(result);
        } else {
            const result = [];
            for (let i = 0; i < iconSel.length; ++i) {
                if (iconSel[i] !== node.index) {
                    result.push(iconSel[i])
                }
            }
            setIconSel(result);
        }

    }
    return (<>
        <table border={0}>
            <tbody>
                <tr><td><label>Type:</label></td><td><select value={genType} onChange={handleGenTypeChange}><option value="C">Raw C/++</option><option value="GFX2">GFX 2.x</option></select></td></tr>
                <tr><td>Module id:</td><td><input type="text" value={moduleId} onChange={handleModuleChange} /></td></tr>
                <tr><td><select value={clampAxis} onChange={handleClampAxisChange}><option value="width">width</option><option value="height">height</option></select></td><td><input type="text" value={clampValue} onChange={handleClampValueChange} /></td></tr>
                <tr><td><label>Bit depth:</label></td><td><select value={bitDepth} onChange={handleBitDepthChange}><option value="1">Monochrome</option><option value="2">2 bits/px</option><option value="4">4 bits/px</option><option value="8">8 bits/px</option><option value="0">vector</option></select></td></tr>
            </tbody>
        </table>
        {clampValue && clampValue > 0 && moduleId && moduleId.length > 0 && iconSel && iconSel.length > 0 && (
            <>
                <button onClick={generateContentFile}
                    className="submit"
                >Download header file</button><br />
                <button
                    onClick={generateContentClip}
                    className="submit"
                >Copy to clipboard</button>
            </>)
        }
        <br />
        <h4>Choose</h4>
        <label>Filter:<input type="text" style={{ width: "100%" }} onChange={handleIconFilterChange} /></label>
        <IconContainer icons={filteredIcons(icons, iconFilter, iconSel)} selected={iconSel} filter={iconFilter} clampHeight={clampAxis === "height" ? clampValue : undefined} clampWidth={clampAxis === "width" ? clampValue : undefined} iconChange={handleIconSelectedChange} height={"400px"} />
        <h4>Selected {iconSel.length}&nbsp;items 
        {(bitDepth>0) && (<>&nbsp;({computeBitmapsTotalBytes(icons, iconSel, bitDepth, clampAxis !== "width" ? parseInt(clampValue) : undefined, clampAxis === "width" ? parseInt(clampValue) : undefined)}&nbsp;bytes)</>)}</h4>
        <IconContainer icons={selectedIcons(icons, iconSel)} selected={iconSel} filter={iconFilter} clampHeight={clampAxis === "height" ? clampValue : undefined} clampWidth={clampAxis === "width" ? clampValue : undefined} iconChange={handleIconSelectedChange} height={"200px"} />
        {iconSel.length > 0 && moduleId && moduleId.length > 0 && (<>
            <Suspense fallback={(<div style={{ height: "400px" }}><h3>Loading...</h3></div>)}>
                <>
                    <h3>Preview</h3>
                    <CodeBox syntaxTheme={syntaxTheme} language={getGeneratedLanguage(genType)} gen={genAsync} />
                </>
            </Suspense>
        </>)}
    </>)


}

const IconContainer = (prop) => {
    return (<div id="iconContainer" style={{ borderColor: "black", borderWidth: "1px", borderStyle: "solid", backgroundColor: "white", display: "flex", flexFlow: "wrap", overflow: "auto", paddingLeft: "2%", width: "100%", height: prop.height }}>
        <>{prop.icons.map((icon) => (
            <IconBox key={icon.key} clampHeight={prop.clampHeight} clampWidth={prop.clampWidth} icon={icon} checked={prop.selected.indexOf(icon.index) >= 0} onChange={(evt) => { prop.iconChange(icon, evt); }} />
        )
        )}</>
    </div>);
}
const CodeBox = (prop) => {
    const result = prop.gen.read();
    return (<div style={{ height: "400px", width: "100%", overflowY: "scroll" }}><SyntaxHighlighter style={prop.syntaxTheme} language={prop.language}>{result}</SyntaxHighlighter></div>);

}

export default IconPackGenerator;